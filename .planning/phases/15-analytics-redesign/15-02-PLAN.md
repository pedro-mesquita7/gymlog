---
phase: 15-analytics-redesign
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/hooks/useAnalytics.ts
  - src/hooks/useVolumeAnalytics.ts
  - src/hooks/useProgressionStatus.ts
  - src/hooks/useVolumeThresholds.ts
  - src/hooks/useSummaryStats.ts
autonomous: true

must_haves:
  truths:
    - "All analytics hooks accept a days parameter and refetch when it changes"
    - "useVolumeAnalytics returns averaged weekly sets per muscle group (not raw weekly data)"
    - "useSummaryStats returns total workouts, volume, PRs, and streak for given time range"
    - "useVolumeThresholds returns 5-zone thresholds per muscle group using VOLUME_ZONE_DEFAULTS"
  artifacts:
    - path: "src/hooks/useAnalytics.ts"
      provides: "Parameterized useExerciseProgress hook"
      contains: "days"
    - path: "src/hooks/useVolumeAnalytics.ts"
      provides: "Parameterized useVolumeAnalytics returning avg weekly sets"
      contains: "days"
    - path: "src/hooks/useProgressionStatus.ts"
      provides: "Parameterized useProgressionStatus hook"
      contains: "days"
    - path: "src/hooks/useVolumeThresholds.ts"
      provides: "5-zone threshold getter using VOLUME_ZONE_DEFAULTS"
      contains: "VOLUME_ZONE_DEFAULTS"
    - path: "src/hooks/useSummaryStats.ts"
      provides: "New hook for summary stats dashboard cards"
      contains: "useSummaryStats"
  key_links:
    - from: "src/hooks/useAnalytics.ts"
      to: "src/db/compiled-queries.ts"
      via: "exerciseProgressSQL(days) function call"
      pattern: "exerciseProgressSQL"
    - from: "src/hooks/useVolumeAnalytics.ts"
      to: "src/db/compiled-queries.ts"
      via: "volumeByMuscleGroupSQL(days) function call"
      pattern: "volumeByMuscleGroupSQL"
    - from: "src/hooks/useSummaryStats.ts"
      to: "src/db/compiled-queries.ts"
      via: "summaryStatsSQL(days) function call"
      pattern: "summaryStatsSQL"
---

<objective>
Parameterize all analytics hooks to accept a `days` parameter, migrate from SQL constants to factory functions, create the new useSummaryStats hook, and update useVolumeThresholds to use the 5-zone system.

Purpose: Hooks are the bridge between the SQL data layer (Plan 01) and UI components (Plans 03-05). Every chart and stat card depends on hooks providing time-filtered data.
Output: 4 updated hooks accepting `days` parameter + 1 new useSummaryStats hook. All re-fetch when `days` changes.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/15-analytics-redesign/15-CONTEXT.md
@.planning/phases/15-analytics-redesign/15-RESEARCH.md
@src/hooks/useAnalytics.ts
@src/hooks/useVolumeAnalytics.ts
@src/hooks/useProgressionStatus.ts
@src/hooks/useVolumeThresholds.ts
@src/types/analytics.ts
@src/db/compiled-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parameterize useAnalytics hooks (useExerciseProgress + useWeeklyComparison)</name>
  <files>src/hooks/useAnalytics.ts</files>
  <action>
Modify `useExerciseProgress` to accept `days` parameter:

1. Update the options interface:
```typescript
interface UseExerciseProgressOptions {
  exerciseId: string;
  days: number | null;  // null = all time
}
```

2. Import `exerciseProgressSQL` function instead of `EXERCISE_PROGRESS_SQL` constant:
```typescript
import { exerciseProgressSQL, WEEKLY_COMPARISON_SQL } from '../db/compiled-queries';
```

3. In `fetchData` callback, generate SQL dynamically:
```typescript
const sql = exerciseProgressSQL(days).replace('$1', `'${exerciseId}'`);
```

4. Add `days` to the `useCallback` dependency array:
```typescript
const fetchData = useCallback(async () => { ... }, [exerciseId, days]);
```

**DO NOT modify `useWeeklyComparison`** — per CONTEXT.md decision, it always uses 14 days (the constant). Keep it unchanged.

**Add abortedRef pattern** to prevent stale data on rapid time range switching:
```typescript
const fetchData = useCallback(async () => {
  // ... existing guards ...
  const abortedRef = { current: false };
  setIsLoading(true);
  setError(null);
  try {
    const conn = await db.connect();
    const sql = exerciseProgressSQL(days).replace('$1', `'${exerciseId}'`);
    const result = await conn.query(sql);
    // ... existing row mapping ...
    if (!abortedRef.current) {
      setData(rows);
    }
    await conn.close();
  } catch (err) {
    if (!abortedRef.current) {
      // ... existing error handling ...
    }
  } finally {
    if (!abortedRef.current) {
      setIsLoading(false);
    }
  }
  return () => { abortedRef.current = true; };
}, [exerciseId, days]);
```

Actually, simpler approach: use a `useRef` for abort tracking:
- Add `const abortRef = useRef(false);` at hook top level
- In `useEffect`, set `abortRef.current = false` before calling fetchData, and return cleanup `() => { abortRef.current = true; }`
- Check `abortRef.current` before `setData` and `setIsLoading(false)` calls
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run build`.</verify>
  <done>useExerciseProgress accepts `days` parameter and refetches on change. useWeeklyComparison unchanged. Stale data protection via abortRef.</done>
</task>

<task type="auto">
  <name>Task 2: Parameterize useVolumeAnalytics, useProgressionStatus, and rewrite useVolumeThresholds</name>
  <files>src/hooks/useVolumeAnalytics.ts, src/hooks/useProgressionStatus.ts, src/hooks/useVolumeThresholds.ts</files>
  <action>
**useVolumeAnalytics.ts — Parameterize with `days` and return averaged data:**

1. Change signature: `export function useVolumeAnalytics(days: number | null): UseVolumeAnalyticsReturn`
2. Import `volumeByMuscleGroupSQL`, `muscleHeatMapSQL` instead of constants.
3. Generate SQL dynamically: `const volumeSQL = volumeByMuscleGroupSQL(days);`
4. The new `volumeByMuscleGroupSQL` from Plan 01 returns `muscle_group, avg_weekly_sets` (averaged, not per-week). Update the row mapping to handle the new schema:
   - Map to `VolumeByMuscleGroupAvg[]` instead of `VolumeByMuscleGroup[]`
   - Add new state: `const [volumeAvgData, setVolumeAvgData] = useState<VolumeByMuscleGroupAvg[]>([]);`
   - Keep the old `volumeData` state too for backward compat during transition
5. For heatmap: `const heatMapSQL = muscleHeatMapSQL(days);`
6. Add `days` to `useCallback` dependency array.
7. Backfill zero-data muscle groups for avg data (same STANDARD_MUSCLE_GROUPS pattern but for avgWeeklySets: 0).

Update the return type to also export `volumeAvgData`:
```typescript
return { volumeData, volumeAvgData, heatMapData, isLoading, error, refresh: fetchData };
```

Update `UseVolumeAnalyticsReturn` in `src/types/analytics.ts` to include `volumeAvgData: VolumeByMuscleGroupAvg[]`.

**useProgressionStatus.ts — Parameterize with `days`:**

1. Change signature: `export function useProgressionStatus(days: number | null = null): UseProgressionStatusReturn`
2. Import `progressionStatusSQL` function instead of `PROGRESSION_STATUS_SQL` constant.
3. Generate SQL: `const sql = progressionStatusSQL(days);`
4. Add `days` to `useCallback` dependency array.

**useVolumeThresholds.ts — Rewrite to use 5-zone VOLUME_ZONE_DEFAULTS:**

Replace the entire hook to use the new research-backed defaults. The hook no longer needs localStorage (thresholds are research-based constants, not user-configurable in this version).

```typescript
import { VOLUME_ZONE_DEFAULTS, type VolumeZoneThresholds } from '../types/analytics';

export function useVolumeZoneThresholds() {
  const getThresholds = (muscleGroup: string): VolumeZoneThresholds => {
    return VOLUME_ZONE_DEFAULTS[muscleGroup] || VOLUME_ZONE_DEFAULTS['Chest']; // fallback
  };

  return { getThresholds, defaults: VOLUME_ZONE_DEFAULTS };
}
```

IMPORTANT: Keep the old `useVolumeThresholds` function exported too (it's used by existing components that will be updated in Plans 04-05). Add the new `useVolumeZoneThresholds` alongside it. The old one will be removed when components migrate.
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run build`.</verify>
  <done>useVolumeAnalytics accepts `days`, returns averaged volume data. useProgressionStatus accepts `days`. useVolumeZoneThresholds provides 5-zone research-backed thresholds.</done>
</task>

<task type="auto">
  <name>Task 3: Create useSummaryStats hook</name>
  <files>src/hooks/useSummaryStats.ts</files>
  <action>
Create new file `src/hooks/useSummaryStats.ts`:

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { getDuckDB } from '../db/duckdb-init';
import { summaryStatsSQL } from '../db/compiled-queries';
import type { SummaryStats } from '../types/analytics';

export function useSummaryStats(days: number | null) {
  const [data, setData] = useState<SummaryStats>({ totalWorkouts: 0, totalVolumeKg: 0, totalPrs: 0, streakWeeks: 0 });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const abortRef = useRef(false);

  const fetchData = useCallback(async () => {
    const db = getDuckDB();
    if (!db) { setError('Database not initialized'); setIsLoading(false); return; }

    abortRef.current = false;
    setIsLoading(true);
    setError(null);

    try {
      const conn = await db.connect();

      // Get summary stats from SQL
      const sql = summaryStatsSQL(days);
      const result = await conn.query(sql);
      const rows = result.toArray();
      const row = rows[0] as any;

      // Calculate streak: count consecutive weeks with >= 1 workout, backwards from current
      const streakSQL = `
        WITH workout_dates AS (
          SELECT DISTINCT DATE_TRUNC('week', CAST(
            COALESCE(payload->>'logged_at', CAST(_created_at AS VARCHAR)) AS TIMESTAMPTZ
          ))::DATE AS week_start
          FROM events
          WHERE event_type = 'workout_started'
        )
        SELECT week_start FROM workout_dates ORDER BY week_start DESC
      `;
      const streakResult = await conn.query(streakSQL);
      const streakRows = streakResult.toArray();

      let streakWeeks = 0;
      if (streakRows.length > 0) {
        // Get current week start
        const now = new Date();
        const dayOfWeek = now.getDay(); // 0=Sun
        const mondayOffset = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
        const currentWeekStart = new Date(now);
        currentWeekStart.setDate(now.getDate() - mondayOffset);
        currentWeekStart.setHours(0, 0, 0, 0);

        // Convert DB rows to week start timestamps
        const weekStarts = streakRows.map((r: any) => {
          const val = r.week_start;
          if (typeof val === 'number') return val;
          if (typeof val === 'bigint') return Number(val);
          return new Date(val).getTime();
        });

        // Count consecutive weeks backward from current
        const ONE_WEEK_MS = 7 * 24 * 60 * 60 * 1000;
        let expectedWeek = currentWeekStart.getTime();

        for (const weekMs of weekStarts) {
          // Allow 1 day tolerance for timezone differences
          if (Math.abs(weekMs - expectedWeek) < ONE_WEEK_MS * 0.5) {
            streakWeeks++;
            expectedWeek -= ONE_WEEK_MS;
          } else if (weekMs < expectedWeek) {
            // Skipped a week, streak broken
            break;
          }
          // If weekMs > expectedWeek, it's a future week entry, skip
        }
      }

      if (!abortRef.current) {
        setData({
          totalWorkouts: Number(row?.total_workouts || 0),
          totalVolumeKg: Number(row?.total_volume_kg || 0),
          totalPrs: Number(row?.total_prs || 0),
          streakWeeks,
        });
      }

      await conn.close();
    } catch (err) {
      if (!abortRef.current) {
        console.error('Error fetching summary stats:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch summary stats');
      }
    } finally {
      if (!abortRef.current) {
        setIsLoading(false);
      }
    }
  }, [days]);

  useEffect(() => {
    abortRef.current = false;
    fetchData();
    return () => { abortRef.current = true; };
  }, [fetchData]);

  return { data, isLoading, error, refresh: fetchData };
}
```

Note: Streak calculation is done in JavaScript (counting consecutive weeks with workouts backward from current week) as recommended in RESEARCH.md to avoid complex recursive SQL.
  </action>
  <verify>Run `npx tsc --noEmit`. Run `npm run build`.</verify>
  <done>useSummaryStats hook created. Accepts `days` parameter. Returns totalWorkouts, totalVolumeKg, totalPrs, streakWeeks. Streak computed in JS from workout dates.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- All hooks accept `days` parameter
- `grep -r "exerciseProgressSQL" src/hooks/` confirms function import
- `grep -r "useSummaryStats" src/hooks/` confirms new hook exists
- `grep -r "useVolumeZoneThresholds" src/hooks/` confirms new threshold hook
- Old hook signatures still work (backward compat for un-migrated components)
</verification>

<success_criteria>
- useExerciseProgress({ exerciseId, days }) refetches on days change
- useVolumeAnalytics(days) returns volumeAvgData with average weekly sets per muscle group
- useProgressionStatus(days) parameterizes progression SQL with min 63-day window
- useVolumeZoneThresholds() returns VOLUME_ZONE_DEFAULTS-based getThresholds function
- useSummaryStats(days) returns totalWorkouts, totalVolumeKg, totalPrs, streakWeeks
- No stale data: abortRef pattern prevents out-of-order state updates
- App builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-analytics-redesign/15-02-SUMMARY.md`
</output>
