---
phase: 04-data-durability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/useBackupStore.ts
  - src/hooks/useBackupExport.ts
  - src/components/workout/WorkoutComplete.tsx
autonomous: true

must_haves:
  truths:
    - "User can download all events as Parquet file"
    - "Backup counter increments when workout is completed"
    - "Backup counter resets when export is triggered"
  artifacts:
    - path: "src/stores/useBackupStore.ts"
      provides: "Backup state with counter and timestamp"
      exports: ["useBackupStore"]
    - path: "src/hooks/useBackupExport.ts"
      provides: "Export functionality with DuckDB COPY TO"
      exports: ["useBackupExport"]
  key_links:
    - from: "src/hooks/useBackupExport.ts"
      to: "src/stores/useBackupStore.ts"
      via: "resetBackupCount call on successful export"
      pattern: "resetBackupCount"
    - from: "src/components/workout/WorkoutComplete.tsx"
      to: "src/stores/useBackupStore.ts"
      via: "incrementWorkoutCount call"
      pattern: "incrementWorkoutCount"
---

<objective>
Create backup store and export functionality for data durability.

Purpose: Enable users to export their workout data as Parquet files for backup, with automatic tracking of workouts since last backup.
Output: Working export flow that downloads a Parquet file containing all events.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-durability/04-RESEARCH.md
@src/stores/useWorkoutStore.ts
@src/db/duckdb-init.ts
@src/components/workout/WorkoutComplete.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backup store with Zustand persist</name>
  <files>src/stores/useBackupStore.ts</files>
  <action>
Create Zustand store with persist middleware for backup tracking:

Interface:
```typescript
interface BackupState {
  workoutsSinceBackup: number;
  lastBackupDate: string | null;
  reminderDismissed: boolean;

  incrementWorkoutCount: () => void;
  resetBackupCount: () => void;
  dismissReminder: () => void;
}
```

Implementation details:
- Use `persist` middleware with `localStorage` (NOT sessionStorage - needs to survive tab close)
- Storage key: 'gymlog-backup'
- `incrementWorkoutCount`: increment counter AND set reminderDismissed to false (reset dismiss on new workout)
- `resetBackupCount`: set counter to 0, lastBackupDate to current ISO timestamp, reminderDismissed to false
- `dismissReminder`: set reminderDismissed to true
- Export BACKUP_THRESHOLD constant = 10 (configurable reminder threshold)
- Export selector: `selectShouldShowReminder` that returns true when counter >= threshold AND !reminderDismissed

Follow existing pattern from useWorkoutStore.ts (same Zustand version/syntax).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Store exports useBackupStore with all actions and selectors, persists to localStorage</done>
</task>

<task type="auto">
  <name>Task 2: Create useBackupExport hook</name>
  <files>src/hooks/useBackupExport.ts</files>
  <action>
Create hook that exports all events to a downloadable Parquet file.

Interface:
```typescript
interface UseBackupExport {
  exportBackup: () => Promise<void>;
  isExporting: boolean;
  error: string | null;
}
```

Implementation:
1. Get DuckDB instance via getDuckDB() from duckdb-init.ts
2. Execute COPY TO with zstd compression:
   ```sql
   COPY (SELECT * FROM events ORDER BY _created_at)
   TO 'backup.parquet'
   (FORMAT parquet, COMPRESSION zstd, COMPRESSION_LEVEL 3)
   ```
3. Extract file: `await db.copyFileToBuffer('backup.parquet')`
4. Create Blob: `new Blob([buffer], { type: 'application/octet-stream' })`
5. Create download link: `URL.createObjectURL(blob)`
6. Trigger download with filename: `gymlog-backup-YYYY-MM-DD.parquet`
7. CRITICAL: Call `URL.revokeObjectURL(url)` after download trigger to prevent memory leak
8. Clean up: `await db.dropFile('backup.parquet')`
9. On success: Call `resetBackupCount()` from useBackupStore
10. Handle errors: Check for active workout via useWorkoutStore.session, warn but allow export

Use try/catch/finally pattern for cleanup. Set isExporting during operation.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Hook exports useBackupExport with working exportBackup function that downloads Parquet file</done>
</task>

<task type="auto">
  <name>Task 3: Wire workout completion to increment counter</name>
  <files>src/components/workout/WorkoutComplete.tsx</files>
  <action>
Modify WorkoutComplete component to increment backup counter on save:

1. Import useBackupStore and get incrementWorkoutCount action
2. In the handleSave function, after successfully writing workout events to DuckDB, call incrementWorkoutCount()
3. Place the call AFTER the event writing succeeds (not before)

This ensures the counter only increments for actually saved workouts, not cancelled ones.

Note: The actual event writing happens in the parent (ActiveWorkout) but the save confirmation is in WorkoutComplete. Find where onFinish() is called after successful save and add the increment there, or pass incrementWorkoutCount to parent.

Review the component to determine correct hook placement - may need to call from ActiveWorkout.tsx instead if that's where save completes.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Completing a workout increments workoutsSinceBackup counter in localStorage</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. useBackupStore persists to localStorage (check in DevTools > Application > Local Storage)
3. useBackupExport hook compiles without errors
4. WorkoutComplete wired to increment counter
</verification>

<success_criteria>
- Backup store created with persist middleware
- Export hook created with DuckDB COPY TO logic
- Workout completion increments backup counter
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-durability/04-01-SUMMARY.md`
</output>
