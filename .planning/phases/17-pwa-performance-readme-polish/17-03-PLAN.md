---
phase: 17-pwa-performance-readme-polish
plan: 03
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - scripts/check-bundle-size.sh
  - .github/workflows/ci.yml
  - PERFORMANCE.md
autonomous: true

must_haves:
  truths:
    - "Bundle size budget is checked in CI and reports pass/fail per chunk"
    - "Lighthouse performance targets are documented with rationale"
    - "DuckDB-WASM initialization timing is documented"
    - "PERFORMANCE.md exists with budgets, targets, and optimization notes"
  artifacts:
    - path: "scripts/check-bundle-size.sh"
      provides: "Bundle size budget checker"
      contains: "stat"
    - path: "PERFORMANCE.md"
      provides: "Performance documentation"
      contains: "Bundle Size Budget"
    - path: ".github/workflows/ci.yml"
      provides: "CI with bundle size check step"
      contains: "check-bundle-size"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "scripts/check-bundle-size.sh"
      via: "build-deploy job runs bundle check after build"
      pattern: "check-bundle-size"
---

<objective>
Establish performance budgets with CI enforcement and document Lighthouse targets, bundle sizes, and optimization strategies in PERFORMANCE.md.

Purpose: Portfolio reviewers and future maintainers need documented performance expectations (PWA-03, PWA-04). Bundle size budgets in CI prevent accidental regressions.

Output: Bundle size check script in CI, PERFORMANCE.md with documented targets.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-pwa-performance-readme-polish/17-RESEARCH.md
@.github/workflows/ci.yml
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bundle size check script and add to CI</name>
  <files>scripts/check-bundle-size.sh, .github/workflows/ci.yml</files>
  <action>
1. Create `scripts/check-bundle-size.sh`:

```bash
#!/bin/bash
# Bundle size budget checker
# Runs after `npm run build` to verify JS chunk sizes stay within budget.
# Sizes are uncompressed (gzip typically reduces by ~70%).

set -e

DIST_DIR="${1:-dist}"

# Budget limits (KB, uncompressed)
MAX_MAIN_KB=650        # index-*.js (React, Zustand, UI components)
MAX_ANALYTICS_KB=575   # AnalyticsPage-*.js (Recharts, chart components)
MAX_DUCKDB_KB=220      # duckdb-*.js (DuckDB-WASM wrapper)
MAX_TOTAL_JS_KB=1500   # All JS combined

FAIL=0
REPORT=""

check_chunk() {
  local pattern="$1"
  local limit_kb="$2"
  local label="$3"

  local file
  file=$(find "$DIST_DIR/assets" -name "${pattern}*.js" 2>/dev/null | head -1)

  if [ -n "$file" ]; then
    local size_bytes
    size_bytes=$(stat -c%s "$file")
    local size_kb=$(( size_bytes / 1024 ))

    if [ "$size_kb" -gt "$limit_kb" ]; then
      REPORT+="OVER BUDGET: $label is ${size_kb}KB (limit: ${limit_kb}KB) - $file\n"
      FAIL=1
    else
      REPORT+="OK: $label is ${size_kb}KB (limit: ${limit_kb}KB)\n"
    fi
  else
    REPORT+="SKIP: No file matching ${pattern}*.js found\n"
  fi
}

check_chunk "index-" "$MAX_MAIN_KB" "Main bundle"
check_chunk "AnalyticsPage-" "$MAX_ANALYTICS_KB" "Analytics chunk"
check_chunk "duckdb-" "$MAX_DUCKDB_KB" "DuckDB chunk"

# Total JS size
TOTAL_KB=$(find "$DIST_DIR/assets" -name '*.js' -exec stat -c%s {} + 2>/dev/null | awk '{s+=$1} END {printf "%d", s/1024}')
if [ "$TOTAL_KB" -gt "$MAX_TOTAL_JS_KB" ]; then
  REPORT+="OVER BUDGET: Total JS is ${TOTAL_KB}KB (limit: ${MAX_TOTAL_JS_KB}KB)\n"
  FAIL=1
else
  REPORT+="OK: Total JS is ${TOTAL_KB}KB (limit: ${MAX_TOTAL_JS_KB}KB)\n"
fi

echo ""
echo "=== Bundle Size Report ==="
echo -e "$REPORT"
echo "========================="
echo ""

if [ "$FAIL" -eq 1 ]; then
  echo "Bundle size budget EXCEEDED. Review chunks above."
  exit 1
else
  echo "All chunks within budget."
  exit 0
fi
```

Make it executable: `chmod +x scripts/check-bundle-size.sh`

2. Update `.github/workflows/ci.yml`:

Add a "Check bundle size" step in the `build-deploy` job, AFTER the "Build application" step and BEFORE "Configure Pages":

```yaml
      - name: Check bundle size budget
        run: bash scripts/check-bundle-size.sh dist
```

This runs as a warning -- if budgets are exceeded, the build still deploys but the step fails visibly in CI logs. To make it a hard gate, it could be moved to a separate job. For now, keep it in build-deploy as a visible check.

Also remove the "Copy COI serviceworker" step if not already removed in 17-01 (the combined SW is built by vite-plugin-pwa into dist/).

IMPORTANT: The budget limits should be set ~10-15% above current actual sizes to allow for organic growth without false positives. Run `npm run build` first to check current sizes and adjust limits accordingly.
  </action>
  <verify>
- `scripts/check-bundle-size.sh` exists and is executable
- `npm run build && bash scripts/check-bundle-size.sh dist` runs and reports sizes
- All current chunks are within budget (no false positives)
- `.github/workflows/ci.yml` has the bundle size check step
  </verify>
  <done>Bundle size check script created and integrated into CI; current build passes all budget checks</done>
</task>

<task type="auto">
  <name>Task 2: Create PERFORMANCE.md with documented targets</name>
  <files>PERFORMANCE.md</files>
  <action>
Create `PERFORMANCE.md` at project root documenting performance characteristics:

**Structure:**

1. **Bundle Size Budget** table:
   - List each chunk with current size and budget limit
   - Note: sizes are uncompressed; gzip typically reduces by ~70%
   - CI enforcement: `scripts/check-bundle-size.sh`

2. **Code Splitting Strategy**:
   - Analytics page lazy-loaded via React.lazy() (keeps Recharts out of main bundle)
   - DuckDB-WASM in separate chunk via manualChunks
   - Service worker precaches all chunks

3. **Lighthouse Targets**:
   - Performance: 85+ (DuckDB CDN download impacts FCP on first load; cached loads should be 95+)
   - Accessibility: 90+
   - Best Practices: 90+
   - SEO: 90+
   - Note: First load downloads ~9MB DuckDB-WASM from CDN; subsequent loads use SW cache

4. **Runtime Performance**:
   - DuckDB-WASM initialization: typically 500-1500ms depending on device
   - Chart rendering: Recharts lazy-loaded, typically <200ms for datasets under 1000 points
   - SQL query execution: DuckDB vectorized engine, sub-100ms for typical analytics queries

5. **Optimization Notes**:
   - LazyMotion (framer-motion): only loads DOM animation features, not full bundle
   - OPFS persistence: no re-initialization on page refresh
   - Service worker caches CDN resources after first load
   - Font subsetting via @fontsource (only Latin character set)

Run `npm run build` first to get actual current sizes for the table. Use real numbers, not estimates.
  </action>
  <verify>
- `PERFORMANCE.md` exists at project root
- Contains bundle size table with actual current sizes
- Contains Lighthouse target section
- Contains code splitting strategy explanation
- Mentions CI enforcement via check-bundle-size.sh
  </verify>
  <done>PERFORMANCE.md documents bundle size budgets, Lighthouse targets, code splitting strategy, and runtime performance characteristics with actual measured values</done>
</task>

</tasks>

<verification>
1. `scripts/check-bundle-size.sh` exists and is executable
2. `npm run build && bash scripts/check-bundle-size.sh dist` passes
3. `PERFORMANCE.md` exists with real bundle size numbers
4. `.github/workflows/ci.yml` includes bundle size check step
</verification>

<success_criteria>
- Bundle size budget enforced in CI with clear pass/fail reporting
- PERFORMANCE.md documents all performance targets with rationale
- Current build passes all budget checks (no false positives)
- Lighthouse targets documented with notes about DuckDB-WASM impact
</success_criteria>

<output>
After completion, create `.planning/phases/17-pwa-performance-readme-polish/17-03-SUMMARY.md`
</output>
