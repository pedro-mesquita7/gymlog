---
phase: 02-templates-logging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useTemplates.ts
  - src/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "Templates can be created, updated, deleted, and archived"
    - "Template list can be fetched from DuckDB"
  artifacts:
    - path: "src/hooks/useTemplates.ts"
      provides: "Template CRUD operations"
      exports: ["useTemplates"]
    - path: "src/db/queries.ts"
      provides: "getTemplates query"
      contains: "getTemplates"
  key_links:
    - from: "src/hooks/useTemplates.ts"
      to: "src/db/events.ts"
      via: "writeEvent for template operations"
      pattern: "writeEvent"
    - from: "src/hooks/useTemplates.ts"
      to: "src/db/queries.ts"
      via: "getTemplates for fetching"
      pattern: "getTemplates"
---

<objective>
Create the useTemplates hook with CRUD operations and add template query to queries.ts.

Purpose: Enable template management using the same event sourcing pattern established in Phase 1. This hook will be used by the template list and builder components.

Output: useTemplates hook with create/update/delete/archive operations, getTemplates query function.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-templates-logging/02-CONTEXT.md
@src/hooks/useExercises.ts
@src/db/queries.ts
@src/db/events.ts
@src/types/events.ts
@src/types/template.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getTemplates query to queries.ts</name>
  <files>src/db/queries.ts</files>
  <action>
Add a `getTemplates` function to `src/db/queries.ts` following the pattern used for `getExercises`.

The query should:
1. Join template_created and template_updated events
2. Use ROW_NUMBER() to get latest state per template_id
3. Exclude deleted templates (template_deleted events)
4. Parse exercises from JSON payload
5. Include is_archived status from template_archived events

```typescript
export async function getTemplates(): Promise<Template[]> {
  const db = getDuckDB();
  if (!db) throw new Error('Database not initialized');

  const conn = await db.connect();
  try {
    // Get latest template state using event replay
    const result = await conn.query(`
      WITH template_events AS (
        SELECT
          JSON_EXTRACT_STRING(payload, '$.template_id') as template_id,
          JSON_EXTRACT_STRING(payload, '$.name') as name,
          JSON_EXTRACT(payload, '$.exercises') as exercises,
          event_type,
          _created_at,
          ROW_NUMBER() OVER (
            PARTITION BY JSON_EXTRACT_STRING(payload, '$.template_id')
            ORDER BY _created_at DESC
          ) as rn
        FROM events
        WHERE event_type IN ('template_created', 'template_updated', 'template_deleted')
      ),
      archive_status AS (
        SELECT
          JSON_EXTRACT_STRING(payload, '$.template_id') as template_id,
          CAST(JSON_EXTRACT(payload, '$.is_archived') AS BOOLEAN) as is_archived,
          ROW_NUMBER() OVER (
            PARTITION BY JSON_EXTRACT_STRING(payload, '$.template_id')
            ORDER BY _created_at DESC
          ) as rn
        FROM events
        WHERE event_type = 'template_archived'
      )
      SELECT
        t.template_id,
        t.name,
        t.exercises,
        COALESCE(a.is_archived, false) as is_archived
      FROM template_events t
      LEFT JOIN archive_status a ON t.template_id = a.template_id AND a.rn = 1
      WHERE t.rn = 1 AND t.event_type != 'template_deleted'
      ORDER BY t.name ASC
    `);

    return result.toArray().map(row => ({
      template_id: row.template_id as string,
      name: row.name as string,
      exercises: JSON.parse(row.exercises as string) as TemplateExercise[],
      is_archived: row.is_archived as boolean,
    }));
  } finally {
    await conn.close();
  }
}
```

Import Template and TemplateExercise types at top of file.
  </action>
  <verify>TypeScript compiles. Can manually test by calling getTemplates() in browser console after DuckDB initializes.</verify>
  <done>getTemplates query returns array of Template objects with exercises and archive status</done>
</task>

<task type="auto">
  <name>Task 2: Create useTemplates hook</name>
  <files>src/hooks/useTemplates.ts</files>
  <action>
Create `src/hooks/useTemplates.ts` following the pattern from `useExercises.ts`:

```typescript
import { useState, useEffect, useCallback } from 'react';
import { uuidv7 } from 'uuidv7';
import { writeEvent } from '../db/events';
import { getTemplates } from '../db/queries';
import type { Template, TemplateExercise } from '../types/template';
import type {
  TemplateCreatedEvent,
  TemplateUpdatedEvent,
  TemplateDeletedEvent,
  TemplateArchivedEvent,
} from '../types/events';

interface CreateTemplateData {
  name: string;
  exercises: TemplateExercise[];
}

interface UpdateTemplateData {
  name: string;
  exercises: TemplateExercise[];
}

interface UseTemplatesReturn {
  templates: Template[];
  activeTemplates: Template[];  // Non-archived only
  isLoading: boolean;
  error: string | null;
  createTemplate: (data: CreateTemplateData) => Promise<string>;  // Returns template_id
  updateTemplate: (id: string, data: UpdateTemplateData) => Promise<void>;
  deleteTemplate: (id: string) => Promise<void>;
  archiveTemplate: (id: string, archive: boolean) => Promise<void>;
  duplicateTemplate: (id: string, newName: string) => Promise<string>;  // Returns new template_id
  refresh: () => Promise<void>;
}

export function useTemplates(): UseTemplatesReturn {
  const [templates, setTemplates] = useState<Template[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refresh = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const data = await getTemplates();
      setTemplates(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load templates');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    refresh();
  }, [refresh]);

  const createTemplate = useCallback(async (data: CreateTemplateData): Promise<string> => {
    const templateId = uuidv7();
    const event: Omit<TemplateCreatedEvent, '_event_id' | '_created_at'> = {
      event_type: 'template_created',
      template_id: templateId,
      name: data.name,
      exercises: data.exercises,
    };
    await writeEvent(event);
    await refresh();
    return templateId;
  }, [refresh]);

  const updateTemplate = useCallback(async (id: string, data: UpdateTemplateData) => {
    const event: Omit<TemplateUpdatedEvent, '_event_id' | '_created_at'> = {
      event_type: 'template_updated',
      template_id: id,
      name: data.name,
      exercises: data.exercises,
    };
    await writeEvent(event);
    await refresh();
  }, [refresh]);

  const deleteTemplate = useCallback(async (id: string) => {
    const event: Omit<TemplateDeletedEvent, '_event_id' | '_created_at'> = {
      event_type: 'template_deleted',
      template_id: id,
    };
    await writeEvent(event);
    await refresh();
  }, [refresh]);

  const archiveTemplate = useCallback(async (id: string, archive: boolean) => {
    const event: Omit<TemplateArchivedEvent, '_event_id' | '_created_at'> = {
      event_type: 'template_archived',
      template_id: id,
      is_archived: archive,
    };
    await writeEvent(event);
    await refresh();
  }, [refresh]);

  const duplicateTemplate = useCallback(async (id: string, newName: string): Promise<string> => {
    const original = templates.find(t => t.template_id === id);
    if (!original) throw new Error('Template not found');

    return createTemplate({
      name: newName,
      exercises: original.exercises,
    });
  }, [templates, createTemplate]);

  // Filter out archived templates for activeTemplates
  const activeTemplates = templates.filter(t => !t.is_archived);

  return {
    templates,
    activeTemplates,
    isLoading,
    error,
    createTemplate,
    updateTemplate,
    deleteTemplate,
    archiveTemplate,
    duplicateTemplate,
    refresh,
  };
}
```
  </action>
  <verify>TypeScript compiles. Hook can be imported and called in a component.</verify>
  <done>useTemplates hook provides full CRUD operations including archive and duplicate</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. useTemplates can be imported: `import { useTemplates } from './hooks/useTemplates'`
3. Hook returns expected interface with templates array and CRUD functions
</verification>

<success_criteria>
- getTemplates query fetches templates with event replay pattern
- useTemplates hook provides create, update, delete, archive, duplicate operations
- activeTemplates filters out archived templates
- All operations use event sourcing via writeEvent
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-templates-logging/02-02-SUMMARY.md`
</output>
