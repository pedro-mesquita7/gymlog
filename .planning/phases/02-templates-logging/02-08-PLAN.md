---
phase: 02-templates-logging
plan: 08
type: execute
wave: 6
depends_on: ["02-07"]
files_modified:
  - src/components/workout/ActiveWorkout.tsx
  - src/components/workout/WorkoutComplete.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can complete workout and all data is saved"
    - "User can cancel workout with confirmation"
    - "Workout events are written to DuckDB"
    - "App returns to start workout view after complete/cancel"
  artifacts:
    - path: "src/components/workout/WorkoutComplete.tsx"
      provides: "Workout completion summary and save logic"
      contains: "writeEvent"
    - path: "src/components/workout/ActiveWorkout.tsx"
      provides: "Complete and cancel integration"
      contains: "onComplete"
  key_links:
    - from: "src/components/workout/WorkoutComplete.tsx"
      to: "src/db/events.ts"
      via: "writeEvent for workout events"
      pattern: "writeEvent"
    - from: "src/components/workout/ActiveWorkout.tsx"
      to: "src/stores/useWorkoutStore.ts"
      via: "completeWorkout action"
      pattern: "completeWorkout"
---

<objective>
Implement workout completion and cancellation with event persistence.

Purpose: Enable users to finish a workout (saving all logged data) or cancel (discarding). This is the final step in the workout logging flow, persisting data to DuckDB.

Output: WorkoutComplete component for review and save, cancellation with confirmation, event writing to DuckDB.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-templates-logging/02-CONTEXT.md
@src/stores/useWorkoutStore.ts
@src/db/events.ts
@src/types/events.ts
@src/components/workout/ActiveWorkout.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkoutComplete component</name>
  <files>src/components/workout/WorkoutComplete.tsx</files>
  <action>
Create `src/components/workout/WorkoutComplete.tsx` - summary view and save logic:

```typescript
import { useState } from 'react';
import { writeEvent } from '../../db/events';
import type { WorkoutSession } from '../../types/workout-session';
import type { Template } from '../../types/template';
import type { Exercise } from '../../types/database';
import type {
  WorkoutStartedEvent,
  SetLoggedEvent,
  WorkoutCompletedEvent,
} from '../../types/events';

interface WorkoutCompleteProps {
  session: WorkoutSession;
  template: Template;
  exercises: Exercise[];
  onSaved: () => void;
  onCancel: () => void;
}

export function WorkoutComplete({ session, template, exercises, onSaved, onCancel }: WorkoutCompleteProps) {
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Calculate workout stats
  const totalSets = session.sets.length;
  const uniqueExercises = new Set(session.sets.map(s => s.original_exercise_id)).size;
  const totalVolume = session.sets.reduce((sum, s) => sum + (s.weight_kg * s.reps), 0);

  // Find exercises with no logged sets
  const exercisesWithSets = new Set(session.sets.map(s => s.original_exercise_id));
  const incompleteExercises = template.exercises.filter(
    te => !exercisesWithSets.has(te.exercise_id)
  );

  const getExerciseName = (exerciseId: string) =>
    exercises.find(e => e.exercise_id === exerciseId)?.name ?? 'Unknown';

  const handleSave = async () => {
    setIsSaving(true);
    setError(null);

    try {
      // Write workout_started event
      await writeEvent<WorkoutStartedEvent>({
        event_type: 'workout_started',
        workout_id: session.workout_id,
        template_id: session.template_id,
        gym_id: session.gym_id,
        started_at: session.started_at,
      });

      // Write all set_logged events
      for (const set of session.sets) {
        await writeEvent<SetLoggedEvent>({
          event_type: 'set_logged',
          workout_id: session.workout_id,
          set_id: set.set_id,
          exercise_id: set.exercise_id,
          original_exercise_id: set.original_exercise_id,
          weight_kg: set.weight_kg,
          reps: set.reps,
          rir: set.rir,
        });
      }

      // Write workout_completed event
      await writeEvent<WorkoutCompletedEvent>({
        event_type: 'workout_completed',
        workout_id: session.workout_id,
        completed_at: new Date().toISOString(),
      });

      onSaved();
    } catch (err) {
      console.error('Failed to save workout:', err);
      setError(err instanceof Error ? err.message : 'Failed to save workout');
      setIsSaving(false);
    }
  };

  // Calculate duration
  const durationMs = Date.now() - new Date(session.started_at).getTime();
  const durationMins = Math.floor(durationMs / 60000);

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-2">Workout Complete</h2>
        <p className="text-zinc-500">{template.name}</p>
      </div>

      {/* Stats summary */}
      <div className="grid grid-cols-3 gap-4 text-center">
        <div className="bg-zinc-800/50 rounded-lg p-4">
          <div className="text-2xl font-bold text-accent">{totalSets}</div>
          <div className="text-xs text-zinc-500">Sets</div>
        </div>
        <div className="bg-zinc-800/50 rounded-lg p-4">
          <div className="text-2xl font-bold text-accent">{uniqueExercises}</div>
          <div className="text-xs text-zinc-500">Exercises</div>
        </div>
        <div className="bg-zinc-800/50 rounded-lg p-4">
          <div className="text-2xl font-bold text-accent">{durationMins}</div>
          <div className="text-xs text-zinc-500">Minutes</div>
        </div>
      </div>

      {/* Total volume */}
      <div className="text-center text-zinc-500">
        Total volume: <span className="text-zinc-300 font-medium">{totalVolume.toLocaleString()} kg</span>
      </div>

      {/* Warning for incomplete exercises */}
      {incompleteExercises.length > 0 && (
        <div className="bg-yellow-600/10 border border-yellow-600/30 rounded-lg p-4">
          <div className="text-yellow-500 font-medium mb-2">
            {incompleteExercises.length} exercise{incompleteExercises.length !== 1 ? 's' : ''} with no sets:
          </div>
          <ul className="text-sm text-zinc-400">
            {incompleteExercises.map(te => (
              <li key={te.exercise_id}>â€¢ {getExerciseName(te.exercise_id)}</li>
            ))}
          </ul>
        </div>
      )}

      {/* Error message */}
      {error && (
        <div className="bg-red-600/10 border border-red-600/30 rounded-lg p-4 text-red-400">
          {error}
        </div>
      )}

      {/* Action buttons */}
      <div className="flex gap-3 pt-4">
        <button
          onClick={onCancel}
          disabled={isSaving}
          className="flex-1 py-3 bg-zinc-800 hover:bg-zinc-700 rounded-lg transition-colors disabled:opacity-50"
        >
          Go Back
        </button>
        <button
          onClick={handleSave}
          disabled={isSaving || totalSets === 0}
          className="flex-1 py-3 bg-green-600 hover:bg-green-500 font-medium rounded-lg transition-colors disabled:opacity-50"
        >
          {isSaving ? 'Saving...' : 'Save Workout'}
        </button>
      </div>

      {totalSets === 0 && (
        <p className="text-center text-sm text-zinc-500">
          Log at least one set to save this workout
        </p>
      )}
    </div>
  );
}
```

Key features:
- Shows workout stats (sets, exercises, duration, volume)
- Warns about exercises with no logged sets (per CONTEXT.md: warn but allow)
- Writes events in order: workout_started, set_logged[], workout_completed
- Prevents saving if no sets logged
- Shows error if save fails
  </action>
  <verify>Component renders stats. Save button writes events to DuckDB. Error state shows on failure.</verify>
  <done>WorkoutComplete shows summary and saves workout events to database</done>
</task>

<task type="auto">
  <name>Task 2: Update ActiveWorkout with complete/cancel flow</name>
  <files>src/components/workout/ActiveWorkout.tsx</files>
  <action>
Update `src/components/workout/ActiveWorkout.tsx` to handle complete and cancel flows:

Add imports:
```typescript
import { useState } from 'react';
import { WorkoutComplete } from './WorkoutComplete';
import { DeleteConfirmation } from '../DeleteConfirmation';
```

Add state for views:
```typescript
const [view, setView] = useState<'workout' | 'complete'>('workout');
const [showCancelConfirm, setShowCancelConfirm] = useState(false);
```

Update component to show WorkoutComplete view:
```typescript
export function ActiveWorkout({ template, exercises, onFinish, onCancel }: ActiveWorkoutProps) {
  const session = useWorkoutStore(state => state.session);
  const currentIndex = useWorkoutStore(state => state.session?.current_exercise_index ?? 0);
  const setCurrentExerciseIndex = useWorkoutStore(state => state.setCurrentExerciseIndex);
  const completeWorkout = useWorkoutStore(state => state.completeWorkout);
  const cancelWorkout = useWorkoutStore(state => state.cancelWorkout);

  const [view, setView] = useState<'workout' | 'complete'>('workout');
  const [showCancelConfirm, setShowCancelConfirm] = useState(false);

  // ... existing navigation code ...

  if (!session) return null;

  // Show complete view
  if (view === 'complete') {
    return (
      <WorkoutComplete
        session={session}
        template={template}
        exercises={exercises}
        onSaved={() => {
          completeWorkout();
          onFinish();
        }}
        onCancel={() => setView('workout')}
      />
    );
  }

  // Main workout view
  return (
    <div {...swipeHandlers} className="min-h-[60vh]">
      {/* ... existing workout header and ExerciseView ... */}

      {/* Finish/Cancel buttons */}
      <div className="flex gap-3 mt-8 pt-6 border-t border-zinc-800">
        <button
          onClick={() => setShowCancelConfirm(true)}
          className="flex-1 py-3 bg-zinc-800 hover:bg-zinc-700 text-zinc-400 rounded-lg transition-colors"
        >
          Cancel
        </button>
        <button
          onClick={() => setView('complete')}
          className="flex-1 py-3 bg-green-600 hover:bg-green-500 font-medium rounded-lg transition-colors"
        >
          Finish Workout
        </button>
      </div>

      {/* Cancel confirmation */}
      {showCancelConfirm && (
        <DeleteConfirmation
          title="Cancel Workout?"
          message={`This will discard your workout progress. ${session.sets.length} set${session.sets.length !== 1 ? 's' : ''} will be lost.`}
          confirmLabel="Cancel Workout"
          onConfirm={() => {
            cancelWorkout();
            onCancel();
          }}
          onCancel={() => setShowCancelConfirm(false)}
        />
      )}
    </div>
  );
}
```

Update the existing DeleteConfirmation component to accept optional `confirmLabel` prop if it doesn't already support it. If needed, add:

```typescript
// In DeleteConfirmation.tsx, add prop:
interface DeleteConfirmationProps {
  title: string;
  message: string;
  confirmLabel?: string;  // Default to "Delete"
  onConfirm: () => void;
  onCancel: () => void;
}
```
  </action>
  <verify>Finish button shows WorkoutComplete. Cancel shows confirmation. Confirming cancel clears session.</verify>
  <done>ActiveWorkout integrates complete/cancel flows with confirmation</done>
</task>

<task type="auto">
  <name>Task 3: Update App.tsx to integrate active workout</name>
  <files>src/App.tsx</files>
  <action>
Update `src/App.tsx` to fully integrate the active workout flow:

1. Import ActiveWorkout component
2. When workout is active, show ActiveWorkout instead of StartWorkout
3. Handle finish and cancel callbacks to return to start view

Update the renderWorkoutsContent function:

```typescript
import { ActiveWorkout } from './components/workout/ActiveWorkout';

// ... in App component ...

const renderWorkoutsContent = () => {
  // If workout is active, show active workout view
  if (isWorkoutActive && session) {
    const currentTemplate = templates.find(t => t.template_id === session.template_id);

    if (!currentTemplate) {
      // Template was deleted while workout in progress - should not happen normally
      return (
        <div className="text-center py-12 text-red-400">
          Template not found. Please cancel this workout.
        </div>
      );
    }

    return (
      <ActiveWorkout
        template={currentTemplate}
        exercises={exercises}
        onFinish={() => {
          refreshEventCount();
        }}
        onCancel={() => {
          // Session already cleared by cancelWorkout action
        }}
      />
    );
  }

  // No active workout - show start workout or management views
  return (
    <div className="space-y-12">
      {/* Start Workout section - only show if we have gyms and templates */}
      {gyms.length > 0 && templates.filter(t => !t.is_archived).length > 0 && (
        <StartWorkout
          templates={templates}
          gyms={gyms}
          onStarted={() => {
            // Session is already set by startWorkout action
            // Component will re-render showing ActiveWorkout
          }}
        />
      )}

      {/* Gym and exercise management */}
      <GymList
        gyms={gyms}
        isLoading={gymsLoading}
        onCreateGym={handleCreateGym}
        onUpdateGym={handleUpdateGym}
        onDeleteGym={handleDeleteGym}
      />

      <ExerciseList
        exercises={exercises}
        isLoading={exercisesLoading}
        onCreateExercise={handleCreateExercise}
        onUpdateExercise={handleUpdateExercise}
        onDeleteExercise={handleDeleteExercise}
      />
    </div>
  );
};
```

Also ensure loading states handle template loading:

```typescript
// Add templates to loading check if needed
if (!status.isConnected && !status.error) {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="text-zinc-500">Loading...</div>
    </div>
  );
}
```
  </action>
  <verify>Starting workout shows ActiveWorkout. Finishing saves and returns to start. Canceling returns to start.</verify>
  <done>App.tsx fully integrates active workout with start, active, and complete states</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Full workflow test:
   - Create template with exercises
   - Start workout (select gym + template)
   - Log sets for exercises
   - Click Finish -> see summary
   - Click Save Workout -> events written, back to start
3. Cancel workflow:
   - Start workout
   - Log some sets
   - Click Cancel -> confirmation shows set count
   - Confirm cancel -> session cleared, back to start
4. Check DuckDB: `SELECT * FROM events WHERE event_type LIKE 'workout%' OR event_type = 'set_logged'`
</verification>

<success_criteria>
- WorkoutComplete shows stats (sets, exercises, duration, volume)
- Warning displayed for exercises with no sets
- Save writes workout_started, set_logged[], workout_completed events
- Cannot save with 0 sets logged
- Cancel shows confirmation with set count
- Confirming cancel clears session
- App returns to start workout view after complete or cancel
- Event count refreshes after saving workout
</success_criteria>

<output>
After completion, create `.planning/phases/02-templates-logging/02-08-SUMMARY.md`
</output>
