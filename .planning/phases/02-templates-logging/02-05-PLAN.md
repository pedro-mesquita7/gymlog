---
phase: 02-templates-logging
plan: 05
type: execute
wave: 3
depends_on: ["02-03", "02-04"]
files_modified:
  - src/stores/useWorkoutStore.ts
  - src/components/workout/StartWorkout.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can select gym and template to start workout"
    - "Active workout session persists across page refresh"
    - "User sees active workout indicator when session in progress"
  artifacts:
    - path: "src/stores/useWorkoutStore.ts"
      provides: "Active workout session state management"
      contains: "persist"
    - path: "src/components/workout/StartWorkout.tsx"
      provides: "Gym and template selection UI"
      min_lines: 50
  key_links:
    - from: "src/stores/useWorkoutStore.ts"
      to: "zustand"
      via: "create with persist middleware"
      pattern: "persist.*sessionStorage"
    - from: "src/components/workout/StartWorkout.tsx"
      to: "src/stores/useWorkoutStore.ts"
      via: "useWorkoutStore hook"
      pattern: "useWorkoutStore"
---

<objective>
Create Zustand workout store with persist middleware and StartWorkout component for gym/template selection.

Purpose: Enable users to start a workout by selecting a gym and template. The session state persists in sessionStorage so workouts survive page refresh.

Output: useWorkoutStore with Zustand + persist, StartWorkout component with gym/template selection.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-templates-logging/02-RESEARCH.md
@.planning/phases/02-templates-logging/02-CONTEXT.md
@src/types/workout-session.ts
@src/hooks/useTemplates.ts
@src/hooks/useGyms.ts
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand workout store with persist</name>
  <files>src/stores/useWorkoutStore.ts</files>
  <action>
Create `src/stores/useWorkoutStore.ts` following the pattern from RESEARCH.md:

```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { uuidv7 } from 'uuidv7';
import type { WorkoutSession, LoggedSet } from '../types/workout-session';

// Global default rest time in seconds
const DEFAULT_REST_SECONDS = 90;

interface WorkoutState {
  // Session data (null when no active workout)
  session: WorkoutSession | null;

  // Rest timer config
  defaultRestSeconds: number;

  // Actions
  startWorkout: (templateId: string, gymId: string) => void;
  logSet: (
    exerciseId: string,
    originalExerciseId: string,
    data: { weight_kg: number; reps: number; rir: number | null }
  ) => void;
  removeSet: (setId: string) => void;
  setCurrentExerciseIndex: (index: number) => void;
  substituteExercise: (originalId: string, replacementId: string) => void;
  revertSubstitution: (originalId: string) => void;
  addCustomExercise: (exerciseId: string, name: string) => void;
  setDefaultRestSeconds: (seconds: number) => void;
  completeWorkout: () => WorkoutSession | null;  // Returns session for event writing
  cancelWorkout: () => void;
}

export const useWorkoutStore = create<WorkoutState>()(
  persist(
    (set, get) => ({
      session: null,
      defaultRestSeconds: DEFAULT_REST_SECONDS,

      startWorkout: (templateId, gymId) => {
        set({
          session: {
            workout_id: uuidv7(),
            template_id: templateId,
            gym_id: gymId,
            started_at: new Date().toISOString(),
            current_exercise_index: 0,
            sets: [],
            exerciseSubstitutions: {},
            customExercises: {},
          },
        });
      },

      logSet: (exerciseId, originalExerciseId, data) => {
        const session = get().session;
        if (!session) return;

        const newSet: LoggedSet = {
          set_id: uuidv7(),
          exercise_id: exerciseId,
          original_exercise_id: originalExerciseId,
          weight_kg: data.weight_kg,
          reps: data.reps,
          rir: data.rir,
          logged_at: new Date().toISOString(),
        };

        set({
          session: {
            ...session,
            sets: [...session.sets, newSet],
          },
        });
      },

      removeSet: (setId) => {
        const session = get().session;
        if (!session) return;

        set({
          session: {
            ...session,
            sets: session.sets.filter(s => s.set_id !== setId),
          },
        });
      },

      setCurrentExerciseIndex: (index) => {
        const session = get().session;
        if (!session) return;

        set({
          session: {
            ...session,
            current_exercise_index: index,
          },
        });
      },

      substituteExercise: (originalId, replacementId) => {
        const session = get().session;
        if (!session) return;

        set({
          session: {
            ...session,
            exerciseSubstitutions: {
              ...session.exerciseSubstitutions,
              [originalId]: replacementId,
            },
          },
        });
      },

      revertSubstitution: (originalId) => {
        const session = get().session;
        if (!session) return;

        const { [originalId]: _, ...rest } = session.exerciseSubstitutions;
        set({
          session: {
            ...session,
            exerciseSubstitutions: rest,
          },
        });
      },

      addCustomExercise: (exerciseId, name) => {
        const session = get().session;
        if (!session) return;

        set({
          session: {
            ...session,
            customExercises: {
              ...session.customExercises,
              [exerciseId]: name,
            },
          },
        });
      },

      setDefaultRestSeconds: (seconds) => {
        set({ defaultRestSeconds: seconds });
      },

      completeWorkout: () => {
        const session = get().session;
        set({ session: null });
        return session;  // Return for event writing
      },

      cancelWorkout: () => {
        set({ session: null });
      },
    }),
    {
      name: 'gymlog-workout',  // sessionStorage key
      storage: createJSONStorage(() => sessionStorage),  // Clear on tab close
      partialize: (state) => ({
        session: state.session,
        defaultRestSeconds: state.defaultRestSeconds,
      }),
    }
  )
);

// Selector for checking if workout is active
export const selectIsWorkoutActive = (state: WorkoutState) => state.session !== null;

// Selector for getting sets for a specific exercise
export const selectSetsForExercise = (exerciseId: string) => (state: WorkoutState) =>
  state.session?.sets.filter(s => s.original_exercise_id === exerciseId) ?? [];
```

Key patterns from RESEARCH.md:
- createJSONStorage(() => sessionStorage) for tab-scoped persistence
- partialize to only persist session and config, not actions
- Return session from completeWorkout for event writing
- Selectors for common queries
  </action>
  <verify>Store imports without errors. Actions work: startWorkout creates session, logSet adds to sets array.</verify>
  <done>Zustand store manages active workout session with sessionStorage persistence</done>
</task>

<task type="auto">
  <name>Task 2: Create StartWorkout component</name>
  <files>src/components/workout/StartWorkout.tsx</files>
  <action>
Create `src/components/workout/StartWorkout.tsx` - gym and template selection to start a workout.

```typescript
import { useState } from 'react';
import { useWorkoutStore } from '../../stores/useWorkoutStore';
import type { Template } from '../../types/template';
import type { Gym } from '../../types/database';

interface StartWorkoutProps {
  templates: Template[];
  gyms: Gym[];
  onStarted: () => void;  // Callback when workout starts
}

export function StartWorkout({ templates, gyms, onStarted }: StartWorkoutProps) {
  const [selectedGymId, setSelectedGymId] = useState<string>('');
  const [selectedTemplateId, setSelectedTemplateId] = useState<string>('');
  const startWorkout = useWorkoutStore(state => state.startWorkout);

  // Filter to only active (non-archived) templates
  const activeTemplates = templates.filter(t => !t.is_archived);

  const handleStart = () => {
    if (!selectedGymId || !selectedTemplateId) return;
    startWorkout(selectedTemplateId, selectedGymId);
    onStarted();
  };

  const canStart = selectedGymId && selectedTemplateId;

  return (
    <div className="space-y-6">
      <div className="text-center py-8">
        <h2 className="text-2xl font-bold mb-2">Start Workout</h2>
        <p className="text-zinc-500">Select gym and template to begin</p>
      </div>

      {/* Gym selection */}
      <div>
        <label className="block text-sm font-medium text-zinc-400 mb-3">
          Where are you training?
        </label>
        {gyms.length === 0 ? (
          <p className="text-zinc-500 text-sm">
            No gyms yet. Add a gym in the Workouts tab.
          </p>
        ) : (
          <div className="grid gap-2">
            {gyms.map(gym => (
              <button
                key={gym.gym_id}
                type="button"
                onClick={() => setSelectedGymId(gym.gym_id)}
                className={`p-4 rounded-lg text-left transition-colors ${
                  selectedGymId === gym.gym_id
                    ? 'bg-accent/20 border-2 border-accent'
                    : 'bg-zinc-800/50 border-2 border-transparent hover:border-zinc-700'
                }`}
              >
                <div className="font-medium">{gym.name}</div>
                {gym.location && (
                  <div className="text-sm text-zinc-500">{gym.location}</div>
                )}
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Template selection */}
      <div>
        <label className="block text-sm font-medium text-zinc-400 mb-3">
          What workout?
        </label>
        {activeTemplates.length === 0 ? (
          <p className="text-zinc-500 text-sm">
            No templates yet. Create a template in the Templates tab.
          </p>
        ) : (
          <div className="grid gap-2">
            {activeTemplates.map(template => (
              <button
                key={template.template_id}
                type="button"
                onClick={() => setSelectedTemplateId(template.template_id)}
                className={`p-4 rounded-lg text-left transition-colors ${
                  selectedTemplateId === template.template_id
                    ? 'bg-accent/20 border-2 border-accent'
                    : 'bg-zinc-800/50 border-2 border-transparent hover:border-zinc-700'
                }`}
              >
                <div className="font-medium">{template.name}</div>
                <div className="text-sm text-zinc-500">
                  {template.exercises.length} exercises
                </div>
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Start button */}
      <button
        onClick={handleStart}
        disabled={!canStart}
        className="w-full py-4 bg-accent hover:bg-accent/90 text-black font-bold rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
      >
        Start Workout
      </button>
    </div>
  );
}
```

Design decisions from CONTEXT.md:
- Templates are global (not gym-specific) - gym selected at workout start
- Show exercise count for each template
- Only show active (non-archived) templates
  </action>
  <verify>Component renders gym and template options. Selection highlights correctly. Start button calls startWorkout.</verify>
  <done>StartWorkout provides gym and template selection with clear visual feedback</done>
</task>

<task type="auto">
  <name>Task 3: Integrate workout flow into App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Update `src/App.tsx` to:
1. Check for active workout session from store
2. Show StartWorkout when no active session on Workouts tab
3. Show active workout indicator when session exists
4. Add useTemplates hook for template data

```typescript
import { useState } from 'react';
import { useDuckDB } from './hooks/useDuckDB';
import { useExercises } from './hooks/useExercises';
import { useGyms } from './hooks/useGyms';
import { useTemplates } from './hooks/useTemplates';
import { useWorkoutStore, selectIsWorkoutActive } from './stores/useWorkoutStore';
import { ExerciseList } from './components/ExerciseList';
import { GymList } from './components/GymList';
import { TemplateList } from './components/templates/TemplateList';
import { StartWorkout } from './components/workout/StartWorkout';
import { Navigation, type Tab } from './components/Navigation';

function App() {
  const [activeTab, setActiveTab] = useState<Tab>('workouts');
  const { status, eventCount, refreshEventCount } = useDuckDB();

  const { exercises, isLoading: exercisesLoading, createExercise, updateExercise, deleteExercise } = useExercises();
  const { gyms, isLoading: gymsLoading, createGym, updateGym, deleteGym } = useGyms();
  const { templates, isLoading: templatesLoading } = useTemplates();

  const isWorkoutActive = useWorkoutStore(selectIsWorkoutActive);
  const session = useWorkoutStore(state => state.session);

  // Handlers with refreshEventCount (same as before)
  const handleCreateExercise = async (data: Parameters<typeof createExercise>[0]) => {
    await createExercise(data);
    refreshEventCount();
  };
  // ... other handlers remain same

  // Loading state
  if (!status.isConnected && !status.error) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-zinc-500">Loading...</div>
      </div>
    );
  }

  // Error state
  if (status.error) {
    return (
      <div className="min-h-screen flex items-center justify-center p-6">
        <div className="max-w-sm">
          <p className="text-red-500 font-mono text-sm mb-4">{status.error}</p>
          <button
            onClick={() => window.location.reload()}
            className="text-sm text-zinc-400 hover:text-white transition-colors"
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  // Render Workouts tab content
  const renderWorkoutsContent = () => {
    // If workout is active, show active workout view (placeholder for now)
    if (isWorkoutActive && session) {
      return (
        <div className="text-center py-12">
          <div className="text-accent text-sm font-medium mb-2">Workout in progress</div>
          <p className="text-zinc-500 mb-6">
            Started at {new Date(session.started_at).toLocaleTimeString()}
          </p>
          <p className="text-zinc-400 text-sm">
            (Active workout UI coming in next plan)
          </p>
        </div>
      );
    }

    // Show start workout or gym/exercise management
    return (
      <div className="space-y-12">
        {/* Start Workout section */}
        {gyms.length > 0 && templates.filter(t => !t.is_archived).length > 0 && (
          <StartWorkout
            templates={templates}
            gyms={gyms}
            onStarted={() => {}}  // No-op for now, will navigate to active workout
          />
        )}

        {/* Always show gym/exercise management */}
        <GymList
          gyms={gyms}
          isLoading={gymsLoading}
          onCreateGym={handleCreateGym}
          onUpdateGym={handleUpdateGym}
          onDeleteGym={handleDeleteGym}
        />

        <ExerciseList
          exercises={exercises}
          isLoading={exercisesLoading}
          onCreateExercise={handleCreateExercise}
          onUpdateExercise={handleUpdateExercise}
          onDeleteExercise={handleDeleteExercise}
        />
      </div>
    );
  };

  return (
    <div className="min-h-screen pb-20">
      {/* Header */}
      <header className="border-b border-zinc-800">
        <div className="max-w-2xl mx-auto px-6 py-6 flex items-baseline justify-between">
          <h1 className="text-2xl font-bold tracking-tight">
            Gym<span className="text-accent">Log</span>
          </h1>
          <div className="flex items-baseline gap-3">
            {isWorkoutActive && (
              <span className="text-xs text-accent font-medium animate-pulse">
                WORKOUT ACTIVE
              </span>
            )}
            {eventCount > 0 && (
              <span className="text-xs text-zinc-500 font-mono">
                {eventCount} events
              </span>
            )}
            {!status.isPersistent && (
              <span className="text-xs text-zinc-500 font-mono">demo mode</span>
            )}
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-2xl mx-auto px-6 py-10">
        {activeTab === 'workouts' ? renderWorkoutsContent() : <TemplateList />}
      </main>

      {/* Bottom Navigation */}
      <Navigation activeTab={activeTab} onTabChange={setActiveTab} />
    </div>
  );
}

export default App;
```

Key additions:
- useWorkoutStore integration with selectIsWorkoutActive
- Active workout indicator in header (pulsing "WORKOUT ACTIVE")
- StartWorkout component shown when gyms and templates exist
- Placeholder for active workout view (next plan)
  </action>
  <verify>App shows StartWorkout when gyms and templates exist. Starting workout shows active indicator. Session persists after refresh.</verify>
  <done>App integrates workout store with visual feedback for active workout state</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Creating workout: select gym + template, click Start
3. Session persists: refresh page, "WORKOUT ACTIVE" still shows
4. Session data correct: check sessionStorage for gymlog-workout key
5. Store actions work: logSet adds to sets array
</verification>

<success_criteria>
- Zustand store created with persist middleware
- Session persists in sessionStorage
- StartWorkout shows gym and template selection
- Starting workout updates session state
- Header shows "WORKOUT ACTIVE" indicator when session exists
- Session survives page refresh
</success_criteria>

<output>
After completion, create `.planning/phases/02-templates-logging/02-05-SUMMARY.md`
</output>
