---
phase: 11-cicd-portfolio
plan: 05
type: execute
wave: 2
depends_on: ["11-04"]
files_modified:
  - src/hooks/useDataQuality.ts
  - src/components/settings/DataQualitySection.tsx
  - src/components/backup/BackupSettings.tsx
autonomous: true

must_haves:
  truths:
    - "User sees data quality summary showing pass/fail status for each dbt test"
    - "User can trigger data quality checks on demand (not automatic on page load)"
    - "User sees anomaly count from the anomaly detection model"
    - "Tests run against live user data in DuckDB-WASM (not pre-computed)"
  artifacts:
    - path: "src/hooks/useDataQuality.ts"
      provides: "Hook that runs compiled dbt test SQL against live DuckDB data"
      exports: ["useDataQuality"]
    - path: "src/components/settings/DataQualitySection.tsx"
      provides: "Data quality display UI in Settings"
      exports: ["DataQualitySection"]
    - path: "src/components/backup/BackupSettings.tsx"
      provides: "Updated Settings with data quality section"
      contains: "DataQualitySection"
  key_links:
    - from: "src/hooks/useDataQuality.ts"
      to: "src/db/duckdb-init.ts"
      via: "DuckDB query execution"
      pattern: "getDuckDB|conn\\.query"
    - from: "src/hooks/useDataQuality.ts"
      to: "compiled dbt test SQL"
      via: "Hardcoded SQL strings from dbt/target/compiled"
      pattern: "SELECT.*FROM.*WHERE"
    - from: "src/components/settings/DataQualitySection.tsx"
      to: "src/hooks/useDataQuality.ts"
      via: "Hook import"
      pattern: "useDataQuality"
    - from: "src/components/backup/BackupSettings.tsx"
      to: "src/components/settings/DataQualitySection.tsx"
      via: "Component import and render"
      pattern: "DataQualitySection"
---

<objective>
Add a data quality display to the Settings page that runs compiled dbt test SQL against live user data in DuckDB-WASM and shows pass/fail results plus anomaly counts.

Purpose: Demonstrates data quality monitoring skills. Running dbt tests client-side on live data (not pre-computed at build time) showcases the unique DuckDB-WASM architecture.
Output: useDataQuality hook + DataQualitySection component integrated into Settings
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-cicd-portfolio/11-RESEARCH.md
@src/components/backup/BackupSettings.tsx

The compiled dbt test SQL files are at:
- dbt/target/compiled/gymlog/tests/custom/test_weight_positive.sql
- dbt/target/compiled/gymlog/tests/custom/test_reps_reasonable.sql

Additionally, dbt schema tests (unique, not_null) are compiled in dbt/target/compiled but there are many of them. For the data quality display, focus on:
1. The 2 custom tests (weight positive, reps reasonable) - copy their compiled SQL as string constants
2. An anomaly count query: SELECT COUNT(*) FROM the int_sets__with_anomalies model WHERE is_anomaly = true (or equivalent)
3. A schema test summary: run a few key not_null/unique checks (e.g., events.id not null, dim_exercise.id unique)

Pattern: dbt tests return ROWS for FAILURES. Zero rows = pass. Any rows = fail with failure count.

DuckDB access: getDuckDB() from src/db/duckdb-init.ts.
Design tokens: Same as ObservabilitySection (bg-secondary, text-primary, text-muted, etc.)
ObservabilitySection is already in BackupSettings (added by 11-04), so DataQualitySection goes after it.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDataQuality hook</name>
  <files>src/hooks/useDataQuality.ts</files>
  <action>
First, read the compiled dbt test SQL files to get the exact SQL:
- `dbt/target/compiled/gymlog/tests/custom/test_weight_positive.sql`
- `dbt/target/compiled/gymlog/tests/custom/test_reps_reasonable.sql`

Create a React hook `useDataQuality` that runs data quality checks on demand.

**Interface:**
```typescript
interface DataQualityTest {
  name: string;
  description: string;
  sql: string;
  category: 'custom' | 'schema' | 'anomaly';
}

interface DataQualityResult {
  name: string;
  description: string;
  category: string;
  status: 'pass' | 'fail' | 'error' | 'pending';
  failureCount: number;
  errorMessage?: string;
  durationMs: number;
}

interface DataQualityState {
  results: DataQualityResult[];
  isRunning: boolean;
  lastRunAt: Date | null;
  anomalyCount: number;
  runChecks: () => Promise<void>;
}
```

**Test definitions (hardcoded SQL strings):**
Define an array of `DataQualityTest` objects. Include:
1. The 2 custom tests (copy EXACT SQL from compiled files, adapting table references to use the CTE/subquery pattern that works with the project's DuckDB setup - the compiled SQL references dbt model names which are actually views/tables in DuckDB).
2. Key schema checks (write simple SQL):
   - `SELECT id FROM events WHERE id IS NULL` (events.id not null)
   - `SELECT id, COUNT(*) FROM events GROUP BY id HAVING COUNT(*) > 1` (events.id unique)
3. Anomaly count query:
   - Query `int_sets__with_anomalies` (or replicate its logic) to count anomalies. If the view doesn't exist at runtime (user has no data), handle gracefully.

**Implementation:**
1. `useState` for results array, isRunning flag, lastRunAt timestamp.
2. `runChecks` function (NOT auto-run on mount - user triggers it):
   - Set isRunning = true
   - For each test in the test array:
     - Get DuckDB connection via getDuckDB()
     - Run the SQL wrapped in try/catch
     - Time each query with performance.now()
     - A test PASSES if query returns 0 rows
     - A test FAILS if query returns >0 rows (failureCount = row count)
     - On SQL error, set status 'error' with message (table doesn't exist = expected when no data)
   - Set isRunning = false, update lastRunAt
3. Compute anomalyCount from the anomaly test result.
4. Handle empty database gracefully (all tests may error if tables don't exist yet - show "No data" state).

Export: `export function useDataQuality(): DataQualityState`
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit` passes</verify>
  <done>useDataQuality hook exports test runner that executes compiled dbt test SQL against live DuckDB data on demand.</done>
</task>

<task type="auto">
  <name>Task 2: Create DataQualitySection and integrate into Settings</name>
  <files>src/components/settings/DataQualitySection.tsx, src/components/backup/BackupSettings.tsx</files>
  <action>
**Create DataQualitySection.tsx:**

A Settings section showing data quality test results. Use `useDataQuality` hook.

Layout (matching existing Settings section style):

```
Data Quality
------------
[Run Data Quality Checks] button

(After running:)
Last run: 2 minutes ago

Custom Tests:
  [green checkmark] Weight Positive         PASS    2ms
  [green checkmark] Reps Reasonable         PASS    1ms

Schema Tests:
  [green checkmark] Events ID Not Null      PASS    1ms
  [green checkmark] Events ID Unique        PASS    3ms

Anomaly Detection:
  [yellow warning] 3 anomalies detected in set data

Summary: 4/4 tests passing | 3 anomalies
```

Specific elements:
1. **Run button:** Primary or secondary button. Text changes to "Running..." with disabled state while isRunning.
2. **Results list:** Group by category (custom, schema, anomaly). Each test shows:
   - Status icon: green checkmark for pass, red X for fail, yellow warning for anomaly, gray dash for pending/error
   - Test name and description
   - Duration in ms
   - Failure count if >0
3. **Summary line:** "X/Y tests passing | Z anomalies" at the bottom.
4. **No data state:** If all tests error with table-not-found, show "Load some workout data first to run quality checks."
5. **Pre-run state:** Show the test list with "pending" status and the Run button prominently.

Use design tokens: text-success for pass, text-error for fail, text-warning for anomalies. Use existing Settings section styling (section > h2 pattern).

**Update BackupSettings.tsx:**
Import and render `<DataQualitySection />` AFTER ObservabilitySection (which was added by 11-04). Add an `<hr>` separator before it.

If ObservabilitySection import is not yet present (plans execute independently), add both. The key requirement: DataQualitySection appears at the bottom of Settings, after all other sections.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- DataQualitySection.tsx exists and exports the component
- BackupSettings.tsx imports and renders DataQualitySection
- `npm run build` succeeds
  </verify>
  <done>
Settings page shows data quality section with on-demand test runner. User clicks "Run Data Quality Checks" to execute dbt test SQL against live data. Results show pass/fail with timing. Anomaly count displayed separately.
  </done>
</task>

</tasks>

<verification>
- useDataQuality hook compiles and exports correct interface
- DataQualitySection renders in Settings page
- Run button triggers test execution
- Results display with pass/fail/error status per test
- Anomaly count displays
- Empty database handled gracefully (no crash)
- `npm run build` succeeds
</verification>

<success_criteria>
User can run data quality checks on demand in Settings. Tests execute compiled dbt SQL against live DuckDB data. Results show pass/fail with counts and timing. Anomaly detection count is displayed. Empty data state handled gracefully.
</success_criteria>

<output>
After completion, create `.planning/phases/11-cicd-portfolio/11-05-SUMMARY.md`
</output>
