---
phase: 07-progression-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/compiled-queries.ts
  - src/types/analytics.ts
  - src/hooks/useProgressionStatus.ts
  - src/hooks/useExerciseProgression.ts
  - dbt/models/marts/analytics/vw_progression_status.sql
autonomous: true

must_haves:
  truths:
    - "PROGRESSION_STATUS_SQL query returns status (progressing/plateau/regressing) per exercise per gym"
    - "useProgressionStatus hook returns all exercises with progression status"
    - "useExerciseProgression hook returns single exercise status for workout alerts"
    - "Plateau detection requires BOTH no PR in 4+ weeks AND weight change < 5%"
    - "Regression detection uses 8-week baseline excluding current week"
    - "Minimum 2 sessions required before showing status"
  artifacts:
    - path: "dbt/models/marts/analytics/vw_progression_status.sql"
      provides: "dbt view for progression status detection"
      contains: "plateau_detection"
    - path: "src/db/compiled-queries.ts"
      provides: "PROGRESSION_STATUS_SQL exported constant"
      contains: "PROGRESSION_STATUS_SQL"
    - path: "src/types/analytics.ts"
      provides: "ProgressionStatus type definition"
      contains: "ProgressionStatus"
    - path: "src/hooks/useProgressionStatus.ts"
      provides: "Hook for all exercises progression data"
      exports: ["useProgressionStatus"]
    - path: "src/hooks/useExerciseProgression.ts"
      provides: "Hook for single exercise progression"
      exports: ["useExerciseProgression"]
  key_links:
    - from: "src/hooks/useProgressionStatus.ts"
      to: "src/db/compiled-queries.ts"
      via: "imports PROGRESSION_STATUS_SQL"
      pattern: "PROGRESSION_STATUS_SQL"
    - from: "src/hooks/useExerciseProgression.ts"
      to: "src/db/compiled-queries.ts"
      via: "imports PROGRESSION_STATUS_SQL with exercise filter"
      pattern: "PROGRESSION_STATUS_SQL"
    - from: "src/db/compiled-queries.ts"
      to: "FACT_SETS_SQL"
      via: "CTE composition referencing existing fact_sets"
      pattern: "FACT_SETS_SQL"
---

<objective>
Create the SQL-based progression detection foundation: a comprehensive SQL query using DuckDB window functions for plateau/regression/progressing detection, TypeScript types, and two React hooks (all exercises + single exercise).

Purpose: This is the data layer that powers both the dashboard (Plan 02) and workout alerts (Plan 03). All detection logic lives in SQL for 10-100x performance over JavaScript.
Output: dbt view, compiled SQL query, ProgressionStatus types, useProgressionStatus and useExerciseProgression hooks.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-progression-intelligence/07-RESEARCH.md
@.planning/phases/07-progression-intelligence/07-CONTEXT.md
@src/db/compiled-queries.ts
@src/types/analytics.ts
@src/hooks/useVolumeAnalytics.ts
@src/hooks/useAnalytics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progression status SQL query and dbt view</name>
  <files>
    dbt/models/marts/analytics/vw_progression_status.sql
    src/db/compiled-queries.ts
    src/types/analytics.ts
  </files>
  <action>
1. Create dbt view `dbt/models/marts/analytics/vw_progression_status.sql` with the complete CTE chain from RESEARCH.md Pattern 1 (vw_progression_status SQL View section). Use materialized='view'. The SQL must include:
   - exercise_sessions CTE: aggregate per (original_exercise_id, gym_id, workout_id) from fact_sets + fact_workouts, 9-week lookback
   - session_counts CTE: count sessions per exercise/gym in last 4 weeks, HAVING >= 2
   - last_pr_per_exercise CTE: MAX(logged_at) from fact_prs per original_exercise_id
   - recent_weight_stats CTE: AVG, MIN, MAX weight in 4 weeks per exercise/gym
   - weekly_aggregates CTE: weekly avg weight and total volume
   - baseline_metrics CTE: 8-week rolling baseline using ROWS BETWEEN 8 PRECEDING AND 1 PRECEDING (excludes current week)
   - current_week_metrics CTE: most recent week with weight_drop_pct and volume_drop_pct
   - plateau_detection CTE: no_pr_4wk AND weight_flat (< 5% range)
   - regression_detection CTE: weight_drop_pct >= 10 OR volume_drop_pct >= 20
   - combined_status CTE: priority order regression > plateau > progressing > unknown
   - Final SELECT: original_exercise_id, gym_id, status, session_count_4wk, last_pr_date, weight_drop_pct, volume_drop_pct

2. Add `PROGRESSION_STATUS_SQL` to `src/db/compiled-queries.ts`. Follow the exact same CTE-composition pattern as VOLUME_BY_MUSCLE_GROUP_SQL (inline FACT_SETS_SQL, use workout_events subquery for gym_id). The query must:
   - Inline ${FACT_SETS_SQL} as a CTE
   - Get gym_id from workout_events (same pattern as EXERCISE_HISTORY_SQL)
   - Include a PR detection subquery using the is_pr flag from fact_sets (since fact_prs is not a separate compiled query, use the is_pr/is_weight_pr/is_1rm_pr columns from FACT_SETS_SQL)
   - Return all columns needed by ProgressionStatus type
   - IMPORTANT: Since DuckDB-WASM uses string interpolation (not parameterized queries), do NOT use $1/$2 placeholders. The all-exercises query has no parameters. For single-exercise, filtering happens in the hook.

3. Add ProgressionStatus type to `src/types/analytics.ts`:
   ```typescript
   export interface ProgressionStatus {
     exerciseId: string;
     gymId: string;
     status: 'progressing' | 'plateau' | 'regressing' | 'unknown';
     lastPrDate: string | null;
     sessionCount4wk: number;
     weightDropPct: number | null;
     volumeDropPct: number | null;
   }
   ```
   Also add UseProgressionStatusReturn and UseExerciseProgressionReturn hook return types following the existing UseVolumeAnalyticsReturn pattern.
  </action>
  <verify>
    - `npx tsc --noEmit` passes (types are valid)
    - PROGRESSION_STATUS_SQL is exported from compiled-queries.ts
    - ProgressionStatus type is exported from analytics.ts
    - dbt view file exists with all required CTEs
  </verify>
  <done>
    SQL query compiles with valid TypeScript, dbt view mirrors the compiled query logic, ProgressionStatus type defined with all fields needed for dashboard and alerts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useProgressionStatus and useExerciseProgression hooks</name>
  <files>
    src/hooks/useProgressionStatus.ts
    src/hooks/useExerciseProgression.ts
  </files>
  <action>
1. Create `src/hooks/useProgressionStatus.ts` following the useVolumeAnalytics pattern exactly:
   - Import getDuckDB from '../db/duckdb-init'
   - Import PROGRESSION_STATUS_SQL from '../db/compiled-queries'
   - Import ProgressionStatus from '../types/analytics'
   - useState for data (ProgressionStatus[]), isLoading (true), error (string | null)
   - useCallback fetchData: get db, connect, query PROGRESSION_STATUS_SQL, map rows to ProgressionStatus objects (use String() for IDs, Number() for numeric fields, handle nulls)
   - useEffect to call fetchData on mount
   - Return { data, isLoading, error, refresh: fetchData }

2. Create `src/hooks/useExerciseProgression.ts` for single-exercise lookup:
   - Accept { exerciseId: string; gymId: string } as params
   - Import PROGRESSION_STATUS_SQL and filter results in JavaScript after query (simpler than parameterized SQL given DuckDB-WASM string interpolation pattern)
   - Return { data: ProgressionStatus | null, isLoading, error }
   - Filter: find first row where exerciseId matches AND (gymId matches OR gymId is empty for global exercises)
   - Re-fetch when exerciseId or gymId changes (add to useCallback/useEffect deps)
   - If exerciseId is empty string, skip fetch and return null data immediately

IMPORTANT patterns to follow from useVolumeAnalytics.ts:
- Use `const db = getDuckDB()` not `await getDuckDB()`
- Check `if (!db)` and set error
- Use `await db.connect()` then `await conn.query(SQL)`
- Use `result.toArray().map()` for row mapping
- Close connection with `await conn.close()`
- Wrap in try/catch/finally with setIsLoading(false) in finally
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Both hooks export correctly
    - useProgressionStatus returns { data, isLoading, error, refresh }
    - useExerciseProgression accepts { exerciseId, gymId } and returns { data, isLoading, error }
  </verify>
  <done>
    Both hooks compile, follow established patterns, and provide the data interface needed by ProgressionDashboard (Plan 02) and ProgressionAlert (Plan 03).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- all TypeScript compiles
2. `npm run build` -- Vite build succeeds (no import errors)
3. dbt view exists at dbt/models/marts/analytics/vw_progression_status.sql
4. PROGRESSION_STATUS_SQL exported from compiled-queries.ts
5. Both hooks importable and type-correct
</verification>

<success_criteria>
- PROGRESSION_STATUS_SQL query implements dual-criteria plateau (no PR 4+ weeks AND weight flat < 5%), regression (weight 10%+ OR volume 20%+ from 8-week baseline), gym-aware partitioning, and minimum 2-session requirement
- useProgressionStatus returns all exercises' status
- useExerciseProgression returns single exercise status filtered by exerciseId + gymId
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-progression-intelligence/07-01-SUMMARY.md`
</output>
