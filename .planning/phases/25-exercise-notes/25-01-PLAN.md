---
phase: 25-exercise-notes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/events.ts
  - src/types/workout-session.ts
  - src/stores/useWorkoutStore.ts
  - src/components/workout/WorkoutComplete.tsx
autonomous: true

must_haves:
  truths:
    - "Notes typed during workout are stored in session state"
    - "Notes are written as exercise_note_logged events on workout save"
    - "Empty/whitespace-only notes are NOT written as events"
  artifacts:
    - path: "src/types/events.ts"
      provides: "ExerciseNoteLoggedEvent type in GymLogEvent union"
      contains: "exercise_note_logged"
    - path: "src/types/workout-session.ts"
      provides: "notes field on WorkoutSession"
      contains: "notes: Record<string, string>"
    - path: "src/stores/useWorkoutStore.ts"
      provides: "setNote action and notes initialization"
      contains: "setNote"
    - path: "src/components/workout/WorkoutComplete.tsx"
      provides: "exercise_note_logged event writing loop"
      contains: "exercise_note_logged"
  key_links:
    - from: "src/stores/useWorkoutStore.ts"
      to: "src/types/workout-session.ts"
      via: "notes field in startWorkout initialization"
      pattern: "notes:\\s*\\{\\}"
    - from: "src/components/workout/WorkoutComplete.tsx"
      to: "src/db/events.ts"
      via: "writeEvent for exercise_note_logged"
      pattern: "writeEvent.*exercise_note_logged"
---

<objective>
Add exercise note data layer: event type, session state, store action, and event persistence on workout completion.

Purpose: Establishes the data foundation for exercise notes. Without this, the UI component (Plan 02) has nowhere to store or persist note text.
Output: ExerciseNoteLoggedEvent type, notes field in WorkoutSession, setNote store action, event writing in WorkoutComplete.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-exercise-notes/25-RESEARCH.md

@src/types/events.ts
@src/types/workout-session.ts
@src/stores/useWorkoutStore.ts
@src/components/workout/WorkoutComplete.tsx
@src/db/events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ExerciseNoteLoggedEvent type and extend WorkoutSession with notes field</name>
  <files>src/types/events.ts, src/types/workout-session.ts</files>
  <action>
In `src/types/events.ts`:
1. Add a new `ExerciseNoteLoggedEvent` interface extending `BaseEvent`:
   ```typescript
   export interface ExerciseNoteLoggedEvent extends BaseEvent {
     event_type: 'exercise_note_logged';
     workout_id: string;
     exercise_id: string;           // Actual exercise used (may be substitution)
     original_exercise_id: string;  // Plan's exercise
     note: string;                  // Plain text, max ~70 chars
   }
   ```
2. Add `ExerciseNoteLoggedEvent` to the `GymLogEvent` union type.

In `src/types/workout-session.ts`:
1. Add `notes: Record<string, string>` field to `WorkoutSession` interface. Key is `original_exercise_id`, value is note text.
   Add it after `customExercises` with a comment: `// original_exercise_id -> note text (max ~70 chars)`

Do NOT add any runtime code here -- types only.
  </action>
  <verify>Run `npx tsc --noEmit` -- should pass with zero errors. Grep for `ExerciseNoteLoggedEvent` in events.ts and `notes:` in workout-session.ts.</verify>
  <done>ExerciseNoteLoggedEvent exists in GymLogEvent union. WorkoutSession has notes field typed as Record&lt;string, string&gt;.</done>
</task>

<task type="auto">
  <name>Task 2: Add setNote store action and wire note events into WorkoutComplete</name>
  <files>src/stores/useWorkoutStore.ts, src/components/workout/WorkoutComplete.tsx</files>
  <action>
In `src/stores/useWorkoutStore.ts`:
1. Add `setNote: (originalExerciseId: string, note: string) => void` to the `WorkoutState` interface.
2. Implement `setNote` in the store creator:
   ```typescript
   setNote: (originalExerciseId, note) => {
     const session = get().session;
     if (!session) return;
     set({
       session: {
         ...session,
         notes: {
           ...session.notes,
           [originalExerciseId]: note,
         },
       },
     });
   },
   ```
3. In `startWorkout`, add `notes: {}` to the initial session object (after `customExercises: {}`).
4. In the `merge` function of the persist config, this is already handled by the spread pattern -- but verify the `partialize` function includes `session` (it does). No change needed to partialize/merge.

IMPORTANT: The merge guard in Zustand persist already spreads `persistedState` over `currentState`. If an existing persisted session lacks `notes`, it will be `undefined`. Add a defensive check: in the `merge` callback, after the spread, if the resulting state has a session but session.notes is undefined, set it to `{}`:
   ```typescript
   merge: (persistedState, currentState) => {
     const merged = {
       ...currentState,
       ...(persistedState as Partial<WorkoutState>),
     };
     // Migration guard: sessions persisted before notes field
     if (merged.session && !merged.session.notes) {
       merged.session = { ...merged.session, notes: {} };
     }
     return merged;
   },
   ```

In `src/components/workout/WorkoutComplete.tsx`:
1. Add `ExerciseNoteLoggedEvent` to the import from `../../types/events`.
2. In `handleSave()`, AFTER the loop that writes `set_logged` events and BEFORE the `workout_completed` event, add a loop to write note events:
   ```typescript
   // Write exercise_note_logged events for non-empty notes
   for (const [originalExerciseId, noteText] of Object.entries(session.notes)) {
     if (noteText.trim()) {
       const actualExerciseId = session.exerciseSubstitutions[originalExerciseId] ?? originalExerciseId;
       await writeEvent<ExerciseNoteLoggedEvent>({
         event_type: 'exercise_note_logged',
         workout_id: session.workout_id,
         exercise_id: actualExerciseId,
         original_exercise_id: originalExerciseId,
         note: noteText.trim(),
       });
     }
   }
   ```

IMPORTANT: The `session.notes` may be `undefined` for sessions started before this change. Use `Object.entries(session.notes ?? {})` to guard against this.
  </action>
  <verify>Run `npx tsc --noEmit` -- zero errors. Run `npx vitest run` -- all existing tests pass. Grep WorkoutComplete.tsx for `exercise_note_logged` to confirm event writing loop exists.</verify>
  <done>setNote action exists in workout store. startWorkout initializes notes as empty object. WorkoutComplete writes exercise_note_logged events for non-empty notes. Migration guard handles persisted sessions without notes field.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run` -- all existing tests pass (no regressions)
3. `ExerciseNoteLoggedEvent` is in the `GymLogEvent` union type
4. `WorkoutSession.notes` is typed as `Record<string, string>`
5. `useWorkoutStore` has `setNote` action
6. `WorkoutComplete.tsx` writes `exercise_note_logged` events after set events
7. Empty notes are filtered out before event writing
</verification>

<success_criteria>
- TypeScript compiles cleanly with new types and store action
- All existing tests pass without modification
- Notes data layer is complete: type -> store -> persistence
- No runtime behavior changes for users (no UI yet)
</success_criteria>

<output>
After completion, create `.planning/phases/25-exercise-notes/25-01-SUMMARY.md`
</output>
