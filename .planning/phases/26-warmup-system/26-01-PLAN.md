---
phase: 26-warmup-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/warmup.ts
  - src/stores/useWorkoutStore.ts
  - src/hooks/useWarmupData.ts
autonomous: true

must_haves:
  truths:
    - "Warmup tier config persists across page refreshes"
    - "Existing users without warmupTiers get default values (no crash)"
    - "DuckDB query returns max weight from last completed session for original exercise"
  artifacts:
    - path: "src/utils/warmup.ts"
      provides: "WarmupTier/WarmupSet types, calculateWarmupSets, roundToNearest, DEFAULT_WARMUP_TIERS"
      exports: ["WarmupTier", "WarmupSet", "DEFAULT_WARMUP_TIERS", "calculateWarmupSets", "roundToNearest"]
    - path: "src/stores/useWorkoutStore.ts"
      provides: "warmupTiers state, setWarmupTiers/resetWarmupTiers actions, migration guard"
      contains: "warmupTiers"
    - path: "src/hooks/useWarmupData.ts"
      provides: "useWarmupData hook returning maxWeight from last session"
      exports: ["useWarmupData"]
  key_links:
    - from: "src/stores/useWorkoutStore.ts"
      to: "src/utils/warmup.ts"
      via: "import DEFAULT_WARMUP_TIERS, WarmupTier"
      pattern: "import.*from.*utils/warmup"
    - from: "src/hooks/useWarmupData.ts"
      to: "DuckDB events table"
      via: "SQL query joining set_logged + workout_completed"
      pattern: "workout_completed"
---

<objective>
Create the warmup system data layer: pure calculation utilities, Zustand store extension for tier configuration, and DuckDB hook for querying last session max weight.

Purpose: Establishes all non-UI foundations so that warmup hints and settings editor can be built in Plan 02 with clean imports.
Output: Three files -- warmup.ts (types + math), useWorkoutStore.ts (extended with warmupTiers), useWarmupData.ts (DuckDB hook).
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-warmup-system/26-CONTEXT.md
@.planning/phases/26-warmup-system/26-RESEARCH.md
@src/stores/useWorkoutStore.ts
@src/hooks/useLastSessionData.ts
@src/hooks/useExerciseNotes.ts
@src/db/compiled-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create warmup utilities and extend Zustand store</name>
  <files>src/utils/warmup.ts, src/stores/useWorkoutStore.ts</files>
  <action>
1. Create `src/utils/warmup.ts` with:
   - `WarmupTier` interface: `{ percentage: number; reps: number }`
   - `WarmupSet` interface: `{ weight: number; reps: number; percentage: number }`
   - `DEFAULT_WARMUP_TIERS` constant: `[{ percentage: 50, reps: 5 }, { percentage: 75, reps: 3 }]` typed as `[WarmupTier, WarmupTier]`
   - `roundToNearest(value: number, increment: number): number` -- `Math.round(value / increment) * increment`
   - `calculateWarmupSets(maxWeight: number, tiers: [WarmupTier, WarmupTier]): [WarmupSet, WarmupSet]` -- maps tiers to WarmupSets with `roundToNearest(maxWeight * (tier.percentage / 100), 2.5)`

2. Extend `src/stores/useWorkoutStore.ts`:
   - Import `WarmupTier, DEFAULT_WARMUP_TIERS` from `../utils/warmup`
   - Add to `WorkoutState` interface: `warmupTiers: [WarmupTier, WarmupTier]`, `setWarmupTiers: (tiers: [WarmupTier, WarmupTier]) => void`, `resetWarmupTiers: () => void`
   - Add initial state: `warmupTiers: DEFAULT_WARMUP_TIERS`
   - Add `setWarmupTiers` action: `set({ warmupTiers: tiers })`
   - Add `resetWarmupTiers` action: `set({ warmupTiers: DEFAULT_WARMUP_TIERS })`
   - Add `warmupTiers: state.warmupTiers` to the `partialize` function
   - Add migration guard in `merge` function: `if (!merged.warmupTiers) { merged.warmupTiers = DEFAULT_WARMUP_TIERS; }` (place after existing notes migration guard, import DEFAULT_WARMUP_TIERS at top)

Important: The migration guard uses the spread merge pattern already in the store. Place it right after the notes migration guard line.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero TypeScript errors.
Run `npx vitest run` -- all existing tests pass (no regressions).
Manually verify: `warmupTiers` appears in partialize, merge has the guard, DEFAULT_WARMUP_TIERS is exported.
  </verify>
  <done>
warmup.ts exports WarmupTier, WarmupSet, DEFAULT_WARMUP_TIERS, calculateWarmupSets, roundToNearest. useWorkoutStore has warmupTiers with persist + migration guard. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useWarmupData DuckDB hook</name>
  <files>src/hooks/useWarmupData.ts</files>
  <action>
Create `src/hooks/useWarmupData.ts` following the pattern from `useExerciseNotes.ts` (useState + useEffect + DuckDB query):

1. Export `useWarmupData(originalExerciseId: string): { maxWeight: number | null; isLoading: boolean }`

2. The SQL query must:
   - Find completed workouts via `SELECT payload->>'workout_id' AS workout_id FROM events WHERE event_type = 'workout_completed'` CTE
   - Find set_logged events for the original exercise where `exercise_id = original_exercise_id` (NOT substituted sets -- this is critical per CONTEXT.md)
   - Join with completed_workouts to exclude in-progress/cancelled sessions
   - Find the most recent workout_id (ORDER BY logged_at DESC LIMIT 1)
   - Get MAX(weight_kg) from that single most recent session only
   - Do NOT filter by gym_id (warmup is gym-agnostic per CONTEXT.md)

3. Hook pattern:
   - useState for maxWeight (null) and isLoading (true)
   - useEffect with originalExerciseId dependency
   - Use `useDuckDB()` or the same DuckDB access pattern as useExerciseNotes.ts (check the import)
   - On query result: if rows exist, set maxWeight to the value (could be 0 for bodyweight); if no rows, set maxWeight to null
   - Set isLoading to false after query completes
   - Handle errors gracefully (console.error, set isLoading false, maxWeight stays null)

4. Key anti-patterns to avoid:
   - Do NOT use `gym_id` in the WHERE clause
   - Do NOT use all-time MAX -- must be scoped to the single most recent completed session
   - Do NOT match substituted sets -- filter `exercise_id = '${originalExerciseId}'` AND `original_exercise_id = '${originalExerciseId}'`
   - Use string interpolation for SQL (DuckDB-WASM limitation, consistent with codebase pattern)

Refer to the SQL example in 26-RESEARCH.md Pattern 1 for the exact CTE structure.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero TypeScript errors.
Run `npx vitest run` -- all existing tests pass.
Verify the SQL string contains: `workout_completed`, `original_exercise_id`, `exercise_id`, `ORDER BY`, `LIMIT 1`, `MAX(`, and does NOT contain `gym_id`.
  </verify>
  <done>
useWarmupData hook exported, queries DuckDB for max weight from last completed session of the original exercise. Returns { maxWeight: number | null, isLoading: boolean }. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run` passes with no regressions
3. `src/utils/warmup.ts` exports all 5 items (WarmupTier, WarmupSet, DEFAULT_WARMUP_TIERS, calculateWarmupSets, roundToNearest)
4. `src/stores/useWorkoutStore.ts` has warmupTiers in state, partialize, and merge
5. `src/hooks/useWarmupData.ts` queries by original_exercise_id without gym_id filter
</verification>

<success_criteria>
- warmup.ts: calculateWarmupSets(60, DEFAULT_WARMUP_TIERS) would produce [{weight: 30, reps: 5, percentage: 50}, {weight: 45, reps: 3, percentage: 75}]
- roundToNearest(33, 2.5) would produce 32.5
- useWorkoutStore persists warmupTiers to localStorage
- Existing users get DEFAULT_WARMUP_TIERS via migration guard (no crash)
- useWarmupData returns maxWeight from only the most recent completed session
</success_criteria>

<output>
After completion, create `.planning/phases/26-warmup-system/26-01-SUMMARY.md`
</output>
