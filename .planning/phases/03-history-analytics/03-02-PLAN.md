---
phase: 03-history-analytics
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - dbt/models/intermediate/workouts/int_sets__with_1rm.sql
  - dbt/models/intermediate/workouts/int_sets__with_prs.sql
  - dbt/models/intermediate/workouts/int_sets__with_anomalies.sql
autonomous: true

must_haves:
  truths:
    - "1RM is calculated for each set using Epley formula"
    - "PRs are detected by comparing current weight to previous max"
    - "Anomalies are flagged when weight changes 50%+ from previous session"
  artifacts:
    - path: "dbt/models/intermediate/workouts/int_sets__with_1rm.sql"
      provides: "Sets with estimated 1RM"
      contains: "calculate_1rm"
    - path: "dbt/models/intermediate/workouts/int_sets__with_prs.sql"
      provides: "Sets with PR detection"
      contains: "is_pr"
    - path: "dbt/models/intermediate/workouts/int_sets__with_anomalies.sql"
      provides: "Sets with anomaly flags"
      contains: "is_anomaly"
  key_links:
    - from: "dbt/models/intermediate/workouts/int_sets__with_prs.sql"
      to: "stg_events__set_logged"
      via: "ref()"
      pattern: "ref.*stg_events__set_logged"
---

<objective>
Create intermediate dbt models that add analytical calculations to logged sets.

Purpose: Implements core analytics logic (DATA-10) - 1RM estimation, PR detection (HIST-03), and anomaly detection (DATA-11) as reusable intermediate models.
Output: 3 intermediate models with calculated metrics ready for mart consumption.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-history-analytics/03-RESEARCH.md

# Staging models from 03-01 (reference pattern)
@dbt/models/staging/events/stg_events__set_logged.sql

# Macros from 03-01
@dbt/macros/calculate_1rm.sql
@dbt/macros/detect_anomaly.sql

# Existing intermediate model pattern
@dbt/models/intermediate/workouts/int_exercises__deduplicated.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create int_sets__with_1rm model</name>
  <files>dbt/models/intermediate/workouts/int_sets__with_1rm.sql</files>
  <action>
Create intermediate model that calculates estimated 1RM for each set using the calculate_1rm macro:

```sql
-- Intermediate model: Sets with estimated 1RM (HIST-04)
{{
    config(
        materialized='view'
    )
}}

SELECT
    set_id,
    workout_id,
    exercise_id,
    original_exercise_id,
    weight_kg,
    reps,
    rir,
    logged_at,
    {{ calculate_1rm('weight_kg', 'reps') }} AS estimated_1rm,
    _event_id,
    _created_at
FROM {{ ref('stg_events__set_logged') }}
```

The macro handles the 1-15 rep range filtering internally (returns NULL outside range).
  </action>
  <verify>Run `cd dbt && dbt compile --select int_sets__with_1rm` - should compile without errors</verify>
  <done>Model compiles and includes estimated_1rm column using Epley formula</done>
</task>

<task type="auto">
  <name>Task 2: Create int_sets__with_prs model</name>
  <files>dbt/models/intermediate/workouts/int_sets__with_prs.sql</files>
  <action>
Create intermediate model that detects personal records using window functions (HIST-03):

```sql
-- Intermediate model: Sets with PR detection (HIST-03)
{{
    config(
        materialized='view'
    )
}}

WITH sets_with_history AS (
    SELECT
        s.*,
        -- Previous max weight for this exercise (excluding current row)
        MAX(weight_kg) OVER (
            PARTITION BY exercise_id
            ORDER BY logged_at
            ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ) AS previous_max_weight
    FROM {{ ref('int_sets__with_1rm') }} s
),

pr_detection AS (
    SELECT
        *,
        CASE
            WHEN weight_kg > previous_max_weight THEN true
            WHEN previous_max_weight IS NULL THEN true  -- First set for exercise is always a PR
            ELSE false
        END AS is_weight_pr,
        -- Also detect 1RM PR (highest estimated 1RM)
        CASE
            WHEN estimated_1rm > MAX(estimated_1rm) OVER (
                PARTITION BY exercise_id
                ORDER BY logged_at
                ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
            ) THEN true
            WHEN MAX(estimated_1rm) OVER (
                PARTITION BY exercise_id
                ORDER BY logged_at
                ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
            ) IS NULL THEN true
            ELSE false
        END AS is_1rm_pr
    FROM sets_with_history
)

SELECT
    set_id,
    workout_id,
    exercise_id,
    original_exercise_id,
    weight_kg,
    reps,
    rir,
    logged_at,
    estimated_1rm,
    previous_max_weight,
    is_weight_pr,
    is_1rm_pr,
    (is_weight_pr OR is_1rm_pr) AS is_pr,  -- Combined PR flag
    _event_id,
    _created_at
FROM pr_detection
```

Key: Use `ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING` to exclude current row from MAX calculation.
  </action>
  <verify>Run `cd dbt && dbt compile --select int_sets__with_prs` - should compile without errors</verify>
  <done>Model compiles and detects both weight PRs and 1RM PRs correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create int_sets__with_anomalies model</name>
  <files>dbt/models/intermediate/workouts/int_sets__with_anomalies.sql</files>
  <action>
Create intermediate model that flags anomalous weight jumps (DATA-11):

```sql
-- Intermediate model: Sets with anomaly detection (DATA-11)
{{
    config(
        materialized='view'
    )
}}

WITH sets_with_previous AS (
    SELECT
        s.*,
        -- Previous weight for this exercise (most recent prior set)
        LAG(weight_kg) OVER (
            PARTITION BY exercise_id
            ORDER BY logged_at
        ) AS previous_weight
    FROM {{ ref('int_sets__with_prs') }} s
),

anomaly_detection AS (
    SELECT
        *,
        {{ detect_anomaly('weight_kg', 'previous_weight', 0.50) }} AS is_anomaly,
        CASE
            WHEN previous_weight IS NOT NULL AND previous_weight > 0
            THEN ROUND((weight_kg - previous_weight) / previous_weight * 100, 1)
            ELSE NULL
        END AS weight_change_pct
    FROM sets_with_previous
)

SELECT * FROM anomaly_detection
```

Uses the detect_anomaly macro with 50% threshold.
Includes weight_change_pct for display purposes.
  </action>
  <verify>Run `cd dbt && dbt compile --select int_sets__with_anomalies` - should compile without errors</verify>
  <done>Model compiles and flags anomalies when weight changes exceed 50%</done>
</task>

</tasks>

<verification>
- [ ] All three intermediate models compile successfully
- [ ] int_sets__with_1rm uses calculate_1rm macro
- [ ] int_sets__with_prs uses correct window frame (excludes current row)
- [ ] int_sets__with_anomalies uses detect_anomaly macro
- [ ] Models chain correctly: stg -> 1rm -> prs -> anomalies
</verification>

<success_criteria>
- 3 intermediate models add calculated fields to sets
- PR detection uses MAX OVER with correct ROWS frame
- Anomaly detection flags 50%+ weight changes
- All models follow materialized='view' pattern for efficiency
</success_criteria>

<output>
After completion, create `.planning/phases/03-history-analytics/03-02-SUMMARY.md`
</output>
