---
phase: 03-history-analytics
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - src/db/compiled-queries.ts
autonomous: true

must_haves:
  truths:
    - "Compiled queries available for runtime execution"
    - "FACT_SETS_SQL includes all analytics columns"
    - "EXERCISE_HISTORY_SQL includes gym filtering parameter"
    - "PR_LIST_SQL queries PRs for specific exercise"
  artifacts:
    - path: "src/db/compiled-queries.ts"
      provides: "Runtime SQL queries for React hooks"
      contains: "FACT_SETS_SQL"
      contains: "EXERCISE_HISTORY_SQL"
  key_links:
    - from: "src/db/compiled-queries.ts"
      to: "dbt/models/marts/"
      via: "SQL logic replication"
      pattern: "estimated_1rm"
---

<objective>
Create compiled SQL queries for runtime execution in React hooks.

Purpose: Bridges dbt models (build-time documentation) to runtime execution by providing TypeScript-embedded SQL queries that match dbt model logic (DEV-006 pattern).
Output: Extended compiled-queries.ts with queries for fact_sets, exercise history, PR detection, and PR list.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-history-analytics/03-RESEARCH.md

# Existing compiled queries pattern
@src/db/compiled-queries.ts

# dbt models to replicate
@dbt/models/marts/core/fact_sets.sql
@dbt/models/marts/analytics/vw_exercise_history.sql
@dbt/models/marts/core/fact_prs.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workout and analytics queries to compiled-queries.ts</name>
  <files>src/db/compiled-queries.ts</files>
  <action>
Extend compiled-queries.ts with queries matching dbt mart models. Add these exports:

1. **FACT_SETS_SQL** - Full sets query with analytics:
```typescript
export const FACT_SETS_SQL = `
WITH set_events AS (
    SELECT
        payload->>'set_id' AS set_id,
        payload->>'workout_id' AS workout_id,
        payload->>'exercise_id' AS exercise_id,
        payload->>'original_exercise_id' AS original_exercise_id,
        CAST(payload->>'weight_kg' AS DECIMAL) AS weight_kg,
        CAST(payload->>'reps' AS INTEGER) AS reps,
        CASE WHEN payload->>'rir' = 'null' THEN NULL ELSE CAST(payload->>'rir' AS INTEGER) END AS rir,
        _created_at AS logged_at,
        _event_id,
        _created_at
    FROM events
    WHERE event_type = 'set_logged'
),

sets_with_1rm AS (
    SELECT
        *,
        CASE
            WHEN reps BETWEEN 1 AND 15
            THEN weight_kg * (1 + (reps / 30.0))
            ELSE NULL
        END AS estimated_1rm
    FROM set_events
),

sets_with_prs AS (
    SELECT
        s.*,
        MAX(weight_kg) OVER (
            PARTITION BY exercise_id
            ORDER BY logged_at
            ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ) AS previous_max_weight,
        LAG(weight_kg) OVER (
            PARTITION BY exercise_id
            ORDER BY logged_at
        ) AS previous_weight,
        MAX(estimated_1rm) OVER (
            PARTITION BY exercise_id
            ORDER BY logged_at
            ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ) AS previous_max_1rm
    FROM sets_with_1rm s
),

sets_with_flags AS (
    SELECT
        *,
        CASE
            WHEN weight_kg > previous_max_weight THEN true
            WHEN previous_max_weight IS NULL THEN true
            ELSE false
        END AS is_weight_pr,
        CASE
            WHEN estimated_1rm > previous_max_1rm THEN true
            WHEN previous_max_1rm IS NULL AND estimated_1rm IS NOT NULL THEN true
            ELSE false
        END AS is_1rm_pr,
        CASE
            WHEN previous_weight IS NULL THEN false
            WHEN previous_weight = 0 THEN false
            WHEN ABS((weight_kg - previous_weight) / previous_weight) > 0.50 THEN true
            ELSE false
        END AS is_anomaly,
        CASE
            WHEN previous_weight IS NOT NULL AND previous_weight > 0
            THEN ROUND((weight_kg - previous_weight) / previous_weight * 100, 1)
            ELSE NULL
        END AS weight_change_pct
    FROM sets_with_prs
)

SELECT
    set_id,
    workout_id,
    exercise_id,
    original_exercise_id,
    weight_kg,
    reps,
    rir,
    estimated_1rm,
    is_weight_pr,
    is_1rm_pr,
    (is_weight_pr OR is_1rm_pr) AS is_pr,
    is_anomaly,
    weight_change_pct,
    previous_weight,
    previous_max_weight,
    logged_at,
    _event_id,
    _created_at
FROM sets_with_flags
ORDER BY logged_at DESC
`;
```

2. **EXERCISE_HISTORY_SQL** - Parameterized query for exercise history:
```typescript
export const EXERCISE_HISTORY_SQL = `
WITH workout_events AS (
    SELECT
        payload->>'workout_id' AS workout_id,
        payload->>'gym_id' AS gym_id
    FROM events
    WHERE event_type = 'workout_started'
),

exercise_dim AS (
    ${DIM_EXERCISE_SQL}
),

recent_sets AS (
    SELECT
        f.set_id,
        f.workout_id,
        f.exercise_id,
        f.weight_kg,
        f.reps,
        f.rir,
        f.estimated_1rm,
        f.is_pr,
        f.is_anomaly,
        f.logged_at,
        w.gym_id AS workout_gym_id
    FROM (${FACT_SETS_SQL}) f
    JOIN workout_events w ON f.workout_id = w.workout_id
    WHERE f.logged_at >= CURRENT_DATE - INTERVAL '14 days'
)

SELECT
    r.*,
    e.name AS exercise_name,
    e.is_global,
    CASE
        WHEN e.is_global = true THEN true
        ELSE r.workout_gym_id = $1  -- $1 = current gym_id for filtering
    END AS matches_gym_context
FROM recent_sets r
JOIN exercise_dim e ON r.exercise_id = e.exercise_id
WHERE r.exercise_id = $2  -- $2 = exercise_id to query
ORDER BY r.logged_at DESC
`;
```

3. **PR_LIST_SQL** - PRs for specific exercise:
```typescript
export const PR_LIST_SQL = `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
)

SELECT
    set_id,
    workout_id,
    exercise_id,
    weight_kg,
    reps,
    estimated_1rm,
    CASE
        WHEN is_weight_pr AND is_1rm_pr THEN 'weight_and_1rm'
        WHEN is_weight_pr THEN 'weight'
        WHEN is_1rm_pr THEN '1rm'
    END AS pr_type,
    logged_at
FROM fact_sets
WHERE is_pr = true AND exercise_id = $1
ORDER BY logged_at DESC
`;
```

4. **CURRENT_MAX_SQL** - Current max weight/1RM for exercise (for PR detection during logging):
```typescript
export const CURRENT_MAX_SQL = `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
)

SELECT
    MAX(weight_kg) AS max_weight,
    MAX(estimated_1rm) AS max_1rm
FROM fact_sets
WHERE exercise_id = $1
`;
```

Note: DuckDB-WASM supports $1, $2 positional parameters for prepared statements.
  </action>
  <verify>TypeScript compilation succeeds: `npm run build` (or `npx tsc --noEmit`)</verify>
  <done>compiled-queries.ts exports FACT_SETS_SQL, EXERCISE_HISTORY_SQL, PR_LIST_SQL, CURRENT_MAX_SQL</done>
</task>

</tasks>

<verification>
- [ ] File compiles without TypeScript errors
- [ ] SQL syntax is valid DuckDB (payload->>'field', window functions)
- [ ] Epley formula matches macro: weight * (1 + reps/30.0)
- [ ] Window frames use ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
- [ ] Anomaly threshold is 0.50 (50%)
- [ ] History filters to 14 days
</verification>

<success_criteria>
- compiled-queries.ts exports 4 new SQL queries
- Queries replicate exact logic from dbt models
- Parameters use $1, $2 syntax for DuckDB prepared statements
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-history-analytics/03-04-SUMMARY.md`
</output>
