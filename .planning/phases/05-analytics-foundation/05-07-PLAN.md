---
phase: 05-analytics-foundation
plan: 07
type: execute
wave: 1
depends_on: []
files_modified: [src/db/duckdb-init.ts, src/db/events.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "OPFS database persists data between sessions"
    - "Corrupted OPFS database is automatically cleaned up and retried"
    - "Write operations are flushed to OPFS via CHECKPOINT"
  artifacts:
    - path: "src/db/duckdb-init.ts"
      provides: "OPFS initialization with accessMode, corruption recovery, and CHECKPOINT"
      contains: "accessMode"
    - path: "src/db/events.ts"
      provides: "CHECKPOINT after write operations"
      contains: "CHECKPOINT"
  key_links:
    - from: "src/db/duckdb-init.ts"
      to: "OPFS gymlog.db"
      via: "db.open with READ_WRITE accessMode"
      pattern: "accessMode.*READ_WRITE"
    - from: "src/db/events.ts"
      to: "OPFS persistence"
      via: "CHECKPOINT after INSERT"
      pattern: "CHECKPOINT"
---

<objective>
Fix OPFS database corruption and persistence failures in duckdb-init.ts and events.ts.

Purpose: Three compounding issues prevent data persistence: (1) missing accessMode: READ_WRITE in db.open(), (2) no CHECKPOINT calls so writes stay in WAL and never flush to the .db file, (3) no OPFS cleanup on corruption so a corrupted file blocks all future OPFS attempts forever.

Output: OPFS database initializes correctly with write access, writes are checkpointed, and corruption triggers automatic cleanup + retry.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/db/duckdb-init.ts
@src/db/events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix OPFS initialization with accessMode, corruption recovery, and CHECKPOINT</name>
  <files>src/db/duckdb-init.ts</files>
  <action>
  Rewrite the OPFS initialization logic in src/db/duckdb-init.ts. Keep the overall structure (singleton, worker setup, fallback to in-memory) but fix these issues:

  1. **Add accessMode to db.open() (line 33):** Change from:
     ```typescript
     await db.open({ path: 'opfs://gymlog.db' });
     ```
     To:
     ```typescript
     await db.open({
       path: 'opfs://gymlog.db',
       accessMode: duckdb.DuckDBAccessMode.READ_WRITE,
     });
     ```
     Import note: `DuckDBAccessMode` is already available from the `@duckdb/duckdb-wasm` import (it's an enum on the module).

  2. **Add CHECKPOINT after schema creation (after line 45):** After the CREATE TABLE query succeeds and before `await conn.close()`, add:
     ```typescript
     await conn.query('CHECKPOINT');
     ```
     This flushes the WAL to the .db file ensuring the schema persists.

  3. **Add OPFS corruption recovery in the catch block (lines 49-66):** Replace the existing catch block with logic that:
     a. Detects if the error message contains "not a valid" or "corrupt" or "Could not" (OPFS corruption indicators)
     b. If corruption detected: log a warning, attempt to delete OPFS files using the OPFS API:
        ```typescript
        try {
          const root = await navigator.storage.getDirectory();
          for (const name of ['gymlog.db', 'gymlog.db.wal']) {
            try {
              await root.removeEntry(name);
              console.log(`Deleted corrupted OPFS file: ${name}`);
            } catch {
              // File may not exist, ignore
            }
          }
        } catch (cleanupErr) {
          console.warn('OPFS cleanup failed:', cleanupErr);
        }
        ```
     c. After cleanup, retry OPFS open ONE time with the same accessMode config
     d. If retry succeeds: create schema, run CHECKPOINT, set isPersistent = true
     e. If retry also fails: fall back to in-memory mode (existing fallback logic)
     f. If original error was NOT corruption: fall back to in-memory immediately (don't attempt cleanup)

  4. **Export a checkpoint utility function** at the bottom of the file:
     ```typescript
     export async function checkpoint(): Promise<void> {
       if (!db || !isPersistent) return;
       try {
         const conn = await db.connect();
         await conn.query('CHECKPOINT');
         await conn.close();
       } catch (err) {
         console.warn('CHECKPOINT failed:', err);
       }
     }
     ```

  Keep the existing `getDuckDB()` and `getIsPersistent()` exports unchanged.
  </action>
  <verify>
  Run: `npx tsc --noEmit` to confirm no type errors.
  Grep for `accessMode` in duckdb-init.ts — should find READ_WRITE.
  Grep for `CHECKPOINT` in duckdb-init.ts — should find it in schema creation and checkpoint function.
  Grep for `removeEntry` in duckdb-init.ts — should find OPFS cleanup logic.
  Grep for `export async function checkpoint` — should find the exported utility.
  </verify>
  <done>
  duckdb-init.ts opens OPFS with READ_WRITE accessMode, runs CHECKPOINT after schema creation, cleans up corrupted OPFS files and retries, and exports a checkpoint() utility function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CHECKPOINT call after writeEvent in events.ts</name>
  <files>src/db/events.ts</files>
  <action>
  In src/db/events.ts:

  1. **Add import** for the checkpoint utility:
     ```typescript
     import { getDuckDB, checkpoint } from './duckdb-init';
     ```
     (Change existing import to include `checkpoint`)

  2. **Call checkpoint after successful INSERT in writeEvent function.** After the `conn.close()` in the finally block, add a non-blocking checkpoint call. The best approach is to call it after the try/finally completes but before returning:
     ```typescript
     // Flush to OPFS (non-blocking, fire-and-forget)
     checkpoint();
     ```
     Place this AFTER the finally block closes the connection, BEFORE the `return event;` statement. Do NOT await it — checkpointing should not block the write response. The checkpoint() function already handles errors internally.

  Do NOT add CHECKPOINT calls to read operations (readEvents, readAllEvents). Only writes need checkpointing.
  </action>
  <verify>
  Run: `npx tsc --noEmit` to confirm no type errors.
  Grep for `checkpoint` in events.ts — should find import and call.
  Verify checkpoint() is called only in writeEvent, not in readEvents or readAllEvents.
  </verify>
  <done>
  writeEvent triggers a non-blocking CHECKPOINT after each write, ensuring data is flushed from WAL to OPFS .db file. Read operations unchanged.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- `grep -c "accessMode" src/db/duckdb-init.ts` returns at least 1
- `grep -c "CHECKPOINT" src/db/duckdb-init.ts` returns at least 2 (schema creation + utility)
- `grep -c "CHECKPOINT" src/db/events.ts` returns 0 (uses imported checkpoint function, not raw SQL)
- `grep -c "checkpoint" src/db/events.ts` returns at least 2 (import + call)
- `grep -c "removeEntry" src/db/duckdb-init.ts` returns at least 1
</verification>

<success_criteria>
- OPFS database opens with READ_WRITE accessMode
- Schema creation followed by CHECKPOINT
- Corruption detected and cleaned up automatically with retry
- writeEvent flushes to OPFS via non-blocking checkpoint
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-analytics-foundation/05-07-SUMMARY.md`
</output>
