---
phase: 05-analytics-foundation
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/hooks/useAnalytics.ts
autonomous: true

must_haves:
  truths:
    - "useExerciseProgress hook fetches daily progress for a given exercise"
    - "useWeeklyComparison hook fetches week-over-week data"
    - "Hooks follow useHistory.ts pattern (useState, useCallback, useEffect)"
    - "Data transformed to camelCase TypeScript types from snake_case SQL"
  artifacts:
    - path: "src/hooks/useAnalytics.ts"
      provides: "useExerciseProgress, useWeeklyComparison hooks"
      exports: ["useExerciseProgress", "useWeeklyComparison"]
      min_lines: 80
  key_links:
    - from: "src/hooks/useAnalytics.ts"
      to: "src/db/compiled-queries.ts"
      via: "EXERCISE_PROGRESS_SQL import"
      pattern: "import.*EXERCISE_PROGRESS_SQL"
    - from: "src/hooks/useAnalytics.ts"
      to: "src/db/duckdb-init.ts"
      via: "getDuckDB import"
      pattern: "getDuckDB"
---

<objective>
Create React hooks for fetching analytics data from DuckDB.

Purpose: Provides the data access layer for chart components following existing codebase patterns. Hooks handle loading states, errors, and data transformation from SQL results to TypeScript types.
Output: useExerciseProgress and useWeeklyComparison hooks ready for chart component consumption.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-analytics-foundation/05-RESEARCH.md

# Existing hook pattern to follow
@src/hooks/useHistory.ts

# Types and queries from Plan 02
@src/types/analytics.ts
@src/db/compiled-queries.ts
@src/db/duckdb-init.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useExerciseProgress hook</name>
  <files>
    src/hooks/useAnalytics.ts
  </files>
  <action>
Create src/hooks/useAnalytics.ts with the useExerciseProgress hook:

```typescript
import { useState, useEffect, useCallback } from 'react';
import { getDuckDB } from '../db/duckdb-init';
import { EXERCISE_PROGRESS_SQL, WEEKLY_COMPARISON_SQL } from '../db/compiled-queries';
import type { ProgressPoint, WeeklyComparison, UseExerciseProgressReturn, UseWeeklyComparisonReturn } from '../types/analytics';

interface UseExerciseProgressOptions {
  exerciseId: string;
}

/**
 * Hook for fetching exercise progress data for charts (CHART-01, CHART-02, CHART-03)
 * Returns daily aggregates: max weight, estimated 1RM, volume for last 28 days
 */
export function useExerciseProgress({ exerciseId }: UseExerciseProgressOptions): UseExerciseProgressReturn {
  const [data, setData] = useState<ProgressPoint[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    if (!exerciseId) {
      setData([]);
      setIsLoading(false);
      return;
    }

    const db = getDuckDB();
    if (!db) {
      setError('Database not initialized');
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const conn = await db.connect();

      // Replace $1 parameter with actual value (DuckDB-WASM limitation)
      const sql = EXERCISE_PROGRESS_SQL.replace('$1', `'${exerciseId}'`);
      const result = await conn.query(sql);

      const rows = result.toArray().map((row: any) => ({
        date: String(row.date),
        maxWeight: Number(row.max_weight),
        max1rm: row.max_1rm !== null ? Number(row.max_1rm) : 0,
        totalVolume: Number(row.total_volume),
        setCount: Number(row.set_count),
      })) as ProgressPoint[];

      setData(rows);
      await conn.close();
    } catch (err) {
      console.error('Error fetching exercise progress:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch progress data');
    } finally {
      setIsLoading(false);
    }
  }, [exerciseId]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, isLoading, error, refresh: fetchData };
}
```

Key requirements:
- Follow useHistory.ts pattern exactly
- Transform snake_case SQL columns to camelCase TypeScript
- Handle null/undefined exerciseId gracefully
- Expose refresh function for manual data refresh
  </action>
  <verify>Run `npx tsc --noEmit` - should pass with no type errors</verify>
  <done>useExerciseProgress hook exists, follows useHistory pattern, returns ProgressPoint[]</done>
</task>

<task type="auto">
  <name>Task 2: Create useWeeklyComparison hook</name>
  <files>
    src/hooks/useAnalytics.ts
  </files>
  <action>
Add useWeeklyComparison hook to src/hooks/useAnalytics.ts:

```typescript
/**
 * Hook for fetching week-over-week comparison data (CHART-04)
 * Returns current week vs previous week metrics with percentage changes
 */
export function useWeeklyComparison(): UseWeeklyComparisonReturn {
  const [data, setData] = useState<WeeklyComparison[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    const db = getDuckDB();
    if (!db) {
      setError('Database not initialized');
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const conn = await db.connect();
      const result = await conn.query(WEEKLY_COMPARISON_SQL);

      const rows = result.toArray().map((row: any) => ({
        exerciseId: String(row.exercise_id),
        exerciseName: String(row.exercise_name),
        muscleGroup: String(row.muscle_group),
        weekStart: String(row.week_start),
        maxWeight: Number(row.max_weight),
        max1rm: row.max_1rm !== null ? Number(row.max_1rm) : 0,
        totalVolume: Number(row.total_volume),
        setCount: Number(row.set_count),
        prevMaxWeight: row.prev_max_weight !== null ? Number(row.prev_max_weight) : null,
        prevVolume: row.prev_volume !== null ? Number(row.prev_volume) : null,
        weightChangePct: row.weight_change_pct !== null ? Number(row.weight_change_pct) : null,
        volumeChangePct: row.volume_change_pct !== null ? Number(row.volume_change_pct) : null,
      })) as WeeklyComparison[];

      setData(rows);
      await conn.close();
    } catch (err) {
      console.error('Error fetching weekly comparison:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch weekly comparison');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, isLoading, error, refresh: fetchData };
}
```

Key requirements:
- No exerciseId filter (returns all exercises for overview)
- Handle null percentage changes (first week has no comparison)
- Transform all columns from snake_case to camelCase
  </action>
  <verify>Run `npx tsc --noEmit` - should pass with no type errors</verify>
  <done>useWeeklyComparison hook exists, returns WeeklyComparison[] with change percentages</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes
- [ ] useExerciseProgress accepts { exerciseId } and returns UseExerciseProgressReturn
- [ ] useWeeklyComparison returns UseWeeklyComparisonReturn
- [ ] Both hooks use getDuckDB() and handle connection errors
- [ ] Data transformed from snake_case (SQL) to camelCase (TypeScript)
- [ ] Loading and error states properly managed
</verification>

<success_criteria>
- Both hooks follow useHistory.ts pattern exactly
- useExerciseProgress fetches data for single exercise
- useWeeklyComparison fetches all exercises for overview
- No TypeScript errors
- Hooks ready for chart component consumption
</success_criteria>

<output>
After completion, create `.planning/phases/05-analytics-foundation/05-03-SUMMARY.md`
</output>
