// Compiled SQL queries from dbt models
// These match the logic in dbt/models/marts/core/
// In a full deployment, these would be auto-generated by dbt compile

export const DIM_EXERCISE_SQL = `
WITH all_exercise_events AS (
    SELECT
        _event_id,
        _created_at,
        event_type,
        payload->>'exercise_id' AS exercise_id,
        payload->>'name' AS name,
        payload->>'muscle_group' AS muscle_group,
        CAST(payload->>'is_global' AS BOOLEAN) AS is_global
    FROM events
    WHERE event_type IN ('exercise_created', 'exercise_updated', 'exercise_deleted')
),

deduplicated AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY exercise_id
            ORDER BY _created_at DESC
        ) AS _rn
    FROM all_exercise_events
),

active_exercises AS (
    SELECT
        exercise_id,
        name,
        muscle_group,
        is_global,
        _created_at AS first_created_at,
        _created_at AS last_updated_at
    FROM deduplicated
    WHERE _rn = 1 AND event_type != 'exercise_deleted'
)

SELECT * FROM active_exercises
ORDER BY name
`;

export const DIM_EXERCISE_ALL_SQL = `
WITH all_exercise_events AS (
    SELECT
        _event_id,
        _created_at,
        event_type,
        payload->>'exercise_id' AS exercise_id,
        payload->>'name' AS name,
        payload->>'muscle_group' AS muscle_group,
        CAST(payload->>'is_global' AS BOOLEAN) AS is_global
    FROM events
    WHERE event_type IN ('exercise_created', 'exercise_updated', 'exercise_deleted')
),

deduplicated AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY exercise_id
            ORDER BY _created_at DESC
        ) AS _rn
    FROM all_exercise_events
)

SELECT
    exercise_id,
    name,
    muscle_group,
    is_global,
    event_type,
    _created_at AS last_updated_at
FROM deduplicated
WHERE _rn = 1
ORDER BY name
`;

export const DIM_GYM_SQL = `
WITH all_gym_events AS (
    SELECT
        _event_id,
        _created_at,
        event_type,
        payload->>'gym_id' AS gym_id,
        payload->>'name' AS name,
        NULLIF(payload->>'location', 'null') AS location
    FROM events
    WHERE event_type IN ('gym_created', 'gym_updated', 'gym_deleted')
),

deduplicated AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY gym_id
            ORDER BY _created_at DESC
        ) AS _rn
    FROM all_gym_events
),

active_gyms AS (
    SELECT
        gym_id,
        name,
        location,
        _created_at AS first_created_at,
        _created_at AS last_updated_at
    FROM deduplicated
    WHERE _rn = 1 AND event_type != 'gym_deleted'
)

SELECT * FROM active_gyms
ORDER BY name
`;

export const FACT_SETS_SQL = `
WITH set_events AS (
    SELECT
        payload->>'set_id' AS set_id,
        payload->>'workout_id' AS workout_id,
        payload->>'exercise_id' AS exercise_id,
        payload->>'original_exercise_id' AS original_exercise_id,
        CAST(payload->>'weight_kg' AS DOUBLE) AS weight_kg,
        CAST(payload->>'reps' AS INTEGER) AS reps,
        CASE WHEN payload->>'rir' = 'null' THEN NULL ELSE CAST(payload->>'rir' AS INTEGER) END AS rir,
        COALESCE(payload->>'logged_at', CAST(_created_at AS VARCHAR)) AS logged_at,
        _event_id,
        _created_at
    FROM events
    WHERE event_type = 'set_logged'
),

sets_with_1rm AS (
    SELECT
        *,
        weight_kg * (1 + reps / 30.0) AS estimated_1rm
    FROM set_events
),

sets_with_prs AS (
    SELECT
        s.*,
        MAX(weight_kg) OVER (
            PARTITION BY original_exercise_id
            ORDER BY logged_at
            ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ) AS previous_max_weight,
        MAX(estimated_1rm) OVER (
            PARTITION BY original_exercise_id
            ORDER BY logged_at
            ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ) AS previous_max_1rm
    FROM sets_with_1rm s
),

sets_with_pr_flags AS (
    SELECT
        *,
        CASE
            WHEN previous_max_weight IS NULL THEN true
            WHEN weight_kg > previous_max_weight THEN true
            ELSE false
        END AS is_weight_pr,
        CASE
            WHEN previous_max_1rm IS NULL AND estimated_1rm IS NOT NULL THEN true
            WHEN estimated_1rm IS NOT NULL AND estimated_1rm > previous_max_1rm THEN true
            ELSE false
        END AS is_1rm_pr
    FROM sets_with_prs
),

sets_with_anomalies AS (
    SELECT
        s.*,
        (is_weight_pr OR is_1rm_pr) AS is_pr,
        LAG(weight_kg) OVER (
            PARTITION BY original_exercise_id
            ORDER BY logged_at
        ) AS previous_weight
    FROM sets_with_pr_flags s
),

sets_with_anomaly_flag AS (
    SELECT
        *,
        CASE
            WHEN previous_weight IS NULL OR previous_weight = 0 THEN false
            WHEN ABS((weight_kg - previous_weight) / previous_weight) > 0.50 THEN true
            ELSE false
        END AS is_anomaly,
        CASE
            WHEN previous_weight IS NOT NULL AND previous_weight > 0
            THEN ROUND((weight_kg - previous_weight) / previous_weight * 100, 1)
            ELSE NULL
        END AS weight_change_pct
    FROM sets_with_anomalies
)

SELECT
    set_id,
    workout_id,
    exercise_id,
    original_exercise_id,
    weight_kg,
    reps,
    rir,
    estimated_1rm,
    is_weight_pr,
    is_1rm_pr,
    is_pr,
    is_anomaly,
    weight_change_pct,
    previous_weight,
    previous_max_weight,
    logged_at,
    _event_id,
    _created_at
FROM sets_with_anomaly_flag
ORDER BY logged_at DESC
`;

// Exercise history — parameterized (Phase 15)
export function exerciseHistorySQL(days: number | null): string {
  const timeFilter = days !== null
    ? `CAST(f.logged_at AS TIMESTAMP) >= CURRENT_DATE - INTERVAL '${days} days'`
    : `1=1`;

  return `
WITH workout_events AS (
    SELECT
        payload->>'workout_id' AS workout_id,
        payload->>'gym_id' AS gym_id
    FROM events
    WHERE event_type = 'workout_started'
),

exercise_dim_all AS (
    ${DIM_EXERCISE_ALL_SQL}
),

recent_sets AS (
    SELECT
        f.set_id,
        f.workout_id,
        f.exercise_id,
        f.original_exercise_id,
        f.weight_kg,
        f.reps,
        f.rir,
        f.estimated_1rm,
        f.is_pr,
        f.is_anomaly,
        f.logged_at,
        w.gym_id AS workout_gym_id
    FROM (${FACT_SETS_SQL}) f
    JOIN workout_events w ON f.workout_id = w.workout_id
    WHERE ${timeFilter}
)

SELECT
    r.*,
    e.name AS exercise_name,
    e.is_global,
    CASE
        WHEN e.is_global = true THEN true
        ELSE r.workout_gym_id = $1
    END AS matches_gym_context
FROM recent_sets r
JOIN exercise_dim_all e ON r.exercise_id = e.exercise_id
WHERE r.original_exercise_id = $2
ORDER BY r.logged_at DESC
`;
}

export const PR_LIST_SQL = `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
)

SELECT
    set_id,
    workout_id,
    exercise_id,
    weight_kg,
    reps,
    estimated_1rm,
    CASE
        WHEN is_weight_pr AND is_1rm_pr THEN 'weight_and_1rm'
        WHEN is_weight_pr THEN 'weight'
        WHEN is_1rm_pr THEN '1rm'
    END AS pr_type,
    logged_at
FROM fact_sets
WHERE is_pr = true AND original_exercise_id = $1
ORDER BY logged_at DESC
`;

export const CURRENT_MAX_SQL = `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
)

SELECT
    MAX(weight_kg) AS max_weight,
    MAX(estimated_1rm) AS max_1rm
FROM fact_sets
WHERE original_exercise_id = $1
`;

// Exercise progress for charts — parameterized (Phase 15)
export function exerciseProgressSQL(days: number | null): string {
  const timeFilter = days !== null
    ? `CAST(logged_at AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${days} days'`
    : `1=1`;

  return `
WITH daily_aggregates AS (
    SELECT
        original_exercise_id AS exercise_id,
        DATE_TRUNC('day', CAST(logged_at AS TIMESTAMPTZ))::DATE AS date,
        MAX(weight_kg) AS max_weight,
        MAX(estimated_1rm) AS max_1rm,
        SUM(weight_kg * reps) AS total_volume,
        COUNT(*) AS set_count
    FROM (${FACT_SETS_SQL}) fact_sets
    WHERE ${timeFilter}
    GROUP BY original_exercise_id, DATE_TRUNC('day', CAST(logged_at AS TIMESTAMPTZ))::DATE
),

exercise_dim_all AS (
    ${DIM_EXERCISE_ALL_SQL}
)

SELECT
    d.exercise_id,
    d.date,
    d.max_weight,
    d.max_1rm,
    d.total_volume,
    d.set_count,
    e.name AS exercise_name,
    e.muscle_group
FROM daily_aggregates d
INNER JOIN exercise_dim_all e ON d.exercise_id = e.exercise_id
WHERE d.exercise_id = $1
ORDER BY d.date
`;
}

// Volume by muscle group — parameterized, returns weekly averages (Phase 15)
export function volumeByMuscleGroupSQL(days: number | null): string {
  const timeFilter = days !== null
    ? `WHERE CAST(fs.logged_at AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${days} days'`
    : `WHERE 1=1`;

  return `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
),

exercise_dim_all AS (
    ${DIM_EXERCISE_ALL_SQL}
),

weekly_volume AS (
    SELECT
        DATE_TRUNC('week', CAST(fs.logged_at AS TIMESTAMPTZ))::DATE AS week_start,
        e.muscle_group,
        COUNT(*) AS set_count
    FROM fact_sets fs
    INNER JOIN exercise_dim_all e ON fs.original_exercise_id = e.exercise_id
    ${timeFilter}
    GROUP BY
        DATE_TRUNC('week', CAST(fs.logged_at AS TIMESTAMPTZ))::DATE,
        e.muscle_group
),

avg_volume AS (
    SELECT
        muscle_group,
        ROUND(AVG(set_count), 1) AS avg_weekly_sets
    FROM weekly_volume
    GROUP BY muscle_group
)

SELECT muscle_group, avg_weekly_sets FROM avg_volume ORDER BY muscle_group
`;
}

// Muscle heat map — parameterized (Phase 15)
export function muscleHeatMapSQL(days: number | null): string {
  const timeFilter = days !== null
    ? `CAST(fs.logged_at AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${days} days'`
    : `1=1`;

  return `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
),

exercise_dim_all AS (
    ${DIM_EXERCISE_ALL_SQL}
)

SELECT
    e.muscle_group,
    COUNT(*) AS total_sets,
    MIN(fs.logged_at) AS first_logged_at,
    MAX(fs.logged_at) AS last_logged_at
FROM fact_sets fs
INNER JOIN exercise_dim_all e ON fs.original_exercise_id = e.exercise_id
WHERE ${timeFilter}
GROUP BY e.muscle_group
ORDER BY total_sets DESC
`;
}

// Progression status — parameterized (Phase 15)
// Uses max(days, 63) for 9-week window and max(days, 28) for 4-week window
export function progressionStatusSQL(days: number | null): string {
  const sessionWindowDays = days !== null ? Math.max(days, 63) : 63; // 9 weeks minimum
  const recentWindowDays = days !== null ? Math.max(days, 28) : 28;  // 4 weeks minimum

  return `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
),

workout_events AS (
    SELECT
        payload->>'workout_id' AS workout_id,
        payload->>'gym_id' AS gym_id,
        COALESCE(payload->>'logged_at', CAST(_created_at AS VARCHAR)) AS logged_at
    FROM events
    WHERE event_type = 'workout_started'
),

exercise_sessions AS (
    SELECT
        fs.original_exercise_id,
        w.gym_id,
        w.workout_id,
        w.logged_at AS session_date,
        MAX(fs.weight_kg) AS max_weight_session,
        AVG(fs.weight_kg) AS avg_weight_session,
        SUM(fs.weight_kg * fs.reps) AS volume_session
    FROM fact_sets fs
    INNER JOIN workout_events w ON fs.workout_id = w.workout_id
    WHERE CAST(w.logged_at AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${sessionWindowDays} days'
    GROUP BY fs.original_exercise_id, w.gym_id, w.workout_id, w.logged_at
),

session_counts AS (
    SELECT
        original_exercise_id,
        gym_id,
        COUNT(DISTINCT workout_id) AS session_count_4wk
    FROM exercise_sessions
    WHERE CAST(session_date AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${recentWindowDays} days'
    GROUP BY original_exercise_id, gym_id
    HAVING COUNT(DISTINCT workout_id) >= 2
),

last_pr_per_exercise AS (
    SELECT
        original_exercise_id,
        MAX(logged_at) AS last_pr_date
    FROM fact_sets
    WHERE is_pr = true
    GROUP BY original_exercise_id
),

recent_weight_stats AS (
    SELECT
        es.original_exercise_id,
        es.gym_id,
        AVG(es.max_weight_session) AS avg_weight_4wk,
        MIN(es.max_weight_session) AS min_weight_4wk,
        MAX(es.max_weight_session) AS max_weight_4wk
    FROM exercise_sessions es
    INNER JOIN session_counts sc
        ON es.original_exercise_id = sc.original_exercise_id
        AND es.gym_id = sc.gym_id
    WHERE CAST(es.session_date AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${recentWindowDays} days'
    GROUP BY es.original_exercise_id, es.gym_id
),

weekly_aggregates AS (
    SELECT
        original_exercise_id,
        gym_id,
        DATE_TRUNC('week', CAST(session_date AS TIMESTAMPTZ))::DATE AS week_start,
        AVG(avg_weight_session) AS avg_weight_week,
        SUM(volume_session) AS total_volume_week
    FROM exercise_sessions
    GROUP BY original_exercise_id, gym_id, DATE_TRUNC('week', CAST(session_date AS TIMESTAMPTZ))::DATE
),

baseline_metrics AS (
    SELECT
        original_exercise_id,
        gym_id,
        week_start,
        avg_weight_week,
        total_volume_week,
        AVG(avg_weight_week) OVER (
            PARTITION BY original_exercise_id, gym_id
            ORDER BY week_start
            ROWS BETWEEN 8 PRECEDING AND 1 PRECEDING
        ) AS baseline_avg_weight_8wk,
        AVG(total_volume_week) OVER (
            PARTITION BY original_exercise_id, gym_id
            ORDER BY week_start
            ROWS BETWEEN 8 PRECEDING AND 1 PRECEDING
        ) AS baseline_avg_volume_8wk,
        RANK() OVER (
            PARTITION BY original_exercise_id, gym_id
            ORDER BY week_start DESC
        ) AS week_recency_rank
    FROM weekly_aggregates
),

current_week_metrics AS (
    SELECT
        original_exercise_id,
        gym_id,
        avg_weight_week AS current_avg_weight,
        total_volume_week AS current_volume,
        baseline_avg_weight_8wk,
        baseline_avg_volume_8wk,
        CASE
            WHEN baseline_avg_weight_8wk > 0 THEN
                ROUND(((baseline_avg_weight_8wk - avg_weight_week) / baseline_avg_weight_8wk) * 100, 1)
            ELSE NULL
        END AS weight_drop_pct,
        CASE
            WHEN baseline_avg_volume_8wk > 0 THEN
                ROUND(((baseline_avg_volume_8wk - total_volume_week) / baseline_avg_volume_8wk) * 100, 1)
            ELSE NULL
        END AS volume_drop_pct
    FROM baseline_metrics
    WHERE week_recency_rank = 1
),

plateau_detection AS (
    SELECT
        rws.original_exercise_id,
        rws.gym_id,
        sc.session_count_4wk,
        lpr.last_pr_date,
        CASE
            WHEN lpr.last_pr_date IS NULL THEN true
            WHEN CAST(lpr.last_pr_date AS TIMESTAMPTZ) < CURRENT_DATE - INTERVAL '${recentWindowDays} days' THEN true
            ELSE false
        END AS no_pr_4wk,
        CASE
            WHEN rws.avg_weight_4wk > 0 THEN
                ((rws.max_weight_4wk - rws.min_weight_4wk) / rws.avg_weight_4wk) < 0.05
            ELSE false
        END AS weight_flat
    FROM recent_weight_stats rws
    INNER JOIN session_counts sc
        ON rws.original_exercise_id = sc.original_exercise_id
        AND rws.gym_id = sc.gym_id
    LEFT JOIN last_pr_per_exercise lpr
        ON rws.original_exercise_id = lpr.original_exercise_id
),

regression_detection AS (
    SELECT
        original_exercise_id,
        gym_id,
        weight_drop_pct,
        volume_drop_pct,
        (weight_drop_pct >= 10.0 OR volume_drop_pct >= 20.0) AS is_regressing
    FROM current_week_metrics
),

combined_status AS (
    SELECT
        pd.original_exercise_id,
        pd.gym_id,
        pd.session_count_4wk,
        pd.last_pr_date,
        COALESCE(rd.weight_drop_pct, 0) AS weight_drop_pct,
        COALESCE(rd.volume_drop_pct, 0) AS volume_drop_pct,
        CASE
            WHEN rd.is_regressing THEN 'regressing'
            WHEN pd.no_pr_4wk AND pd.weight_flat THEN 'plateau'
            WHEN NOT pd.no_pr_4wk THEN 'progressing'
            ELSE 'unknown'
        END AS status
    FROM plateau_detection pd
    LEFT JOIN regression_detection rd
        ON pd.original_exercise_id = rd.original_exercise_id
        AND pd.gym_id = rd.gym_id
)

SELECT
    original_exercise_id,
    gym_id,
    status,
    session_count_4wk,
    last_pr_date,
    weight_drop_pct,
    volume_drop_pct
FROM combined_status
ORDER BY original_exercise_id, gym_id
`;
}

// Summary stats — new query (Phase 15)
export function summaryStatsSQL(days: number | null): string {
  const timeFilter = days !== null
    ? `CAST(COALESCE(payload->>'logged_at', CAST(_created_at AS VARCHAR)) AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${days} days'`
    : `1=1`;
  const setsTimeFilter = days !== null
    ? `CAST(logged_at AS TIMESTAMPTZ) >= CURRENT_DATE - INTERVAL '${days} days'`
    : `1=1`;

  return `
    WITH fact_sets AS (${FACT_SETS_SQL}),
    workout_events AS (
      SELECT DISTINCT
        payload->>'workout_id' AS workout_id,
        COALESCE(payload->>'logged_at', CAST(_created_at AS VARCHAR)) AS logged_at
      FROM events
      WHERE event_type = 'workout_started'
        AND ${timeFilter}
    )
    SELECT
      (SELECT COUNT(DISTINCT workout_id) FROM workout_events) AS total_workouts,
      (SELECT COALESCE(SUM(weight_kg * reps), 0) FROM fact_sets WHERE ${setsTimeFilter}) AS total_volume_kg,
      (SELECT COUNT(*) FROM fact_sets WHERE is_pr = true AND ${setsTimeFilter}) AS total_prs
  `;
}

// DEPRECATED: Use function versions. These will be removed after Plan 02 migrates hooks.
export const EXERCISE_HISTORY_SQL = exerciseHistorySQL(14);
export const EXERCISE_PROGRESS_SQL = exerciseProgressSQL(28);
export const VOLUME_BY_MUSCLE_GROUP_SQL = volumeByMuscleGroupSQL(28);
export const MUSCLE_HEAT_MAP_SQL = muscleHeatMapSQL(28);
export const PROGRESSION_STATUS_SQL = progressionStatusSQL(null);
