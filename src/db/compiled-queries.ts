// Compiled SQL queries from dbt models
// These match the logic in dbt/models/marts/core/
// In a full deployment, these would be auto-generated by dbt compile

export const DIM_EXERCISE_SQL = `
WITH all_exercise_events AS (
    SELECT
        _event_id,
        _created_at,
        event_type,
        payload->>'exercise_id' AS exercise_id,
        payload->>'name' AS name,
        payload->>'muscle_group' AS muscle_group,
        CAST(payload->>'is_global' AS BOOLEAN) AS is_global
    FROM events
    WHERE event_type IN ('exercise_created', 'exercise_updated', 'exercise_deleted')
),

deduplicated AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY exercise_id
            ORDER BY _created_at DESC
        ) AS _rn
    FROM all_exercise_events
),

active_exercises AS (
    SELECT
        exercise_id,
        name,
        muscle_group,
        is_global,
        _created_at AS first_created_at,
        _created_at AS last_updated_at
    FROM deduplicated
    WHERE _rn = 1 AND event_type != 'exercise_deleted'
)

SELECT * FROM active_exercises
ORDER BY name
`;

export const DIM_GYM_SQL = `
WITH all_gym_events AS (
    SELECT
        _event_id,
        _created_at,
        event_type,
        payload->>'gym_id' AS gym_id,
        payload->>'name' AS name,
        NULLIF(payload->>'location', 'null') AS location
    FROM events
    WHERE event_type IN ('gym_created', 'gym_updated', 'gym_deleted')
),

deduplicated AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY gym_id
            ORDER BY _created_at DESC
        ) AS _rn
    FROM all_gym_events
),

active_gyms AS (
    SELECT
        gym_id,
        name,
        location,
        _created_at AS first_created_at,
        _created_at AS last_updated_at
    FROM deduplicated
    WHERE _rn = 1 AND event_type != 'gym_deleted'
)

SELECT * FROM active_gyms
ORDER BY name
`;

export const FACT_SETS_SQL = `
WITH set_events AS (
    SELECT
        payload->>'set_id' AS set_id,
        payload->>'workout_id' AS workout_id,
        payload->>'exercise_id' AS exercise_id,
        payload->>'original_exercise_id' AS original_exercise_id,
        CAST(payload->>'weight_kg' AS DECIMAL) AS weight_kg,
        CAST(payload->>'reps' AS INTEGER) AS reps,
        CASE WHEN payload->>'rir' = 'null' THEN NULL ELSE CAST(payload->>'rir' AS INTEGER) END AS rir,
        COALESCE(payload->>'logged_at', CAST(_created_at AS VARCHAR)) AS logged_at,
        _event_id,
        _created_at
    FROM events
    WHERE event_type = 'set_logged'
),

sets_with_1rm AS (
    SELECT
        *,
        weight_kg * (1 + reps / 30.0) AS estimated_1rm
    FROM set_events
),

sets_with_prs AS (
    SELECT
        s.*,
        MAX(weight_kg) OVER (
            PARTITION BY original_exercise_id
            ORDER BY logged_at
            ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ) AS previous_max_weight,
        MAX(estimated_1rm) OVER (
            PARTITION BY original_exercise_id
            ORDER BY logged_at
            ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
        ) AS previous_max_1rm
    FROM sets_with_1rm s
),

sets_with_pr_flags AS (
    SELECT
        *,
        CASE
            WHEN previous_max_weight IS NULL THEN true
            WHEN weight_kg > previous_max_weight THEN true
            ELSE false
        END AS is_weight_pr,
        CASE
            WHEN previous_max_1rm IS NULL AND estimated_1rm IS NOT NULL THEN true
            WHEN estimated_1rm IS NOT NULL AND estimated_1rm > previous_max_1rm THEN true
            ELSE false
        END AS is_1rm_pr
    FROM sets_with_prs
),

sets_with_anomalies AS (
    SELECT
        s.*,
        (is_weight_pr OR is_1rm_pr) AS is_pr,
        LAG(weight_kg) OVER (
            PARTITION BY original_exercise_id
            ORDER BY logged_at
        ) AS previous_weight
    FROM sets_with_pr_flags s
),

sets_with_anomaly_flag AS (
    SELECT
        *,
        CASE
            WHEN previous_weight IS NULL OR previous_weight = 0 THEN false
            WHEN ABS((weight_kg - previous_weight) / previous_weight) > 0.50 THEN true
            ELSE false
        END AS is_anomaly,
        CASE
            WHEN previous_weight IS NOT NULL AND previous_weight > 0
            THEN ROUND((weight_kg - previous_weight) / previous_weight * 100, 1)
            ELSE NULL
        END AS weight_change_pct
    FROM sets_with_anomalies
)

SELECT
    set_id,
    workout_id,
    exercise_id,
    original_exercise_id,
    weight_kg,
    reps,
    rir,
    estimated_1rm,
    is_weight_pr,
    is_1rm_pr,
    is_pr,
    is_anomaly,
    weight_change_pct,
    previous_weight,
    previous_max_weight,
    logged_at,
    _event_id,
    _created_at
FROM sets_with_anomaly_flag
ORDER BY logged_at DESC
`;

export const EXERCISE_HISTORY_SQL = `
WITH workout_events AS (
    SELECT
        payload->>'workout_id' AS workout_id,
        payload->>'gym_id' AS gym_id
    FROM events
    WHERE event_type = 'workout_started'
),

exercise_dim AS (
    ${DIM_EXERCISE_SQL}
),

recent_sets AS (
    SELECT
        f.set_id,
        f.workout_id,
        f.exercise_id,
        f.original_exercise_id,
        f.weight_kg,
        f.reps,
        f.rir,
        f.estimated_1rm,
        f.is_pr,
        f.is_anomaly,
        f.logged_at,
        w.gym_id AS workout_gym_id
    FROM (${FACT_SETS_SQL}) f
    JOIN workout_events w ON f.workout_id = w.workout_id
    WHERE CAST(f.logged_at AS TIMESTAMP) >= CURRENT_DATE - INTERVAL '14 days'
)

SELECT
    r.*,
    e.name AS exercise_name,
    e.is_global,
    CASE
        WHEN e.is_global = true THEN true
        ELSE r.workout_gym_id = $1
    END AS matches_gym_context
FROM recent_sets r
JOIN exercise_dim e ON r.exercise_id = e.exercise_id
WHERE r.original_exercise_id = $2
ORDER BY r.logged_at DESC
`;

export const PR_LIST_SQL = `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
)

SELECT
    set_id,
    workout_id,
    exercise_id,
    weight_kg,
    reps,
    estimated_1rm,
    CASE
        WHEN is_weight_pr AND is_1rm_pr THEN 'weight_and_1rm'
        WHEN is_weight_pr THEN 'weight'
        WHEN is_1rm_pr THEN '1rm'
    END AS pr_type,
    logged_at
FROM fact_sets
WHERE is_pr = true AND original_exercise_id = $1
ORDER BY logged_at DESC
`;

export const CURRENT_MAX_SQL = `
WITH fact_sets AS (
    ${FACT_SETS_SQL}
)

SELECT
    MAX(weight_kg) AS max_weight,
    MAX(estimated_1rm) AS max_1rm
FROM fact_sets
WHERE original_exercise_id = $1
`;

// Exercise progress for charts (mirrors vw_exercise_progress.sql)
export const EXERCISE_PROGRESS_SQL = `
WITH daily_aggregates AS (
    SELECT
        original_exercise_id AS exercise_id,
        DATE_TRUNC('day', CAST(logged_at AS TIMESTAMP))::DATE AS date,
        MAX(weight_kg) AS max_weight,
        MAX(estimated_1rm) AS max_1rm,
        SUM(weight_kg * reps) AS total_volume,
        COUNT(*) AS set_count
    FROM (${FACT_SETS_SQL}) fact_sets
    WHERE CAST(logged_at AS TIMESTAMP) >= CURRENT_DATE - INTERVAL '28 days'
    GROUP BY original_exercise_id, DATE_TRUNC('day', CAST(logged_at AS TIMESTAMP))::DATE
),

exercise_dim AS (
    ${DIM_EXERCISE_SQL}
)

SELECT
    d.exercise_id,
    d.date,
    d.max_weight,
    d.max_1rm,
    d.total_volume,
    d.set_count,
    e.name AS exercise_name,
    e.muscle_group
FROM daily_aggregates d
INNER JOIN exercise_dim e ON d.exercise_id = e.exercise_id
WHERE d.exercise_id = $1
ORDER BY d.date
`;

// Weekly comparison (mirrors vw_weekly_comparison.sql)
export const WEEKLY_COMPARISON_SQL = `
WITH weekly_metrics AS (
    SELECT
        original_exercise_id AS exercise_id,
        DATE_TRUNC('week', CAST(logged_at AS TIMESTAMP))::DATE AS week_start,
        MAX(weight_kg) AS max_weight,
        MAX(estimated_1rm) AS max_1rm,
        SUM(weight_kg * reps) AS total_volume,
        COUNT(*) AS set_count
    FROM (${FACT_SETS_SQL}) fact_sets
    WHERE CAST(logged_at AS TIMESTAMP) >= CURRENT_DATE - INTERVAL '14 days'
    GROUP BY original_exercise_id, DATE_TRUNC('week', CAST(logged_at AS TIMESTAMP))::DATE
),

with_comparison AS (
    SELECT
        exercise_id,
        week_start,
        max_weight,
        max_1rm,
        total_volume,
        set_count,
        LAG(max_weight) OVER (PARTITION BY exercise_id ORDER BY week_start) AS prev_max_weight,
        LAG(total_volume) OVER (PARTITION BY exercise_id ORDER BY week_start) AS prev_volume
    FROM weekly_metrics
),

exercise_dim AS (
    ${DIM_EXERCISE_SQL}
)

SELECT
    w.exercise_id,
    w.week_start,
    w.max_weight,
    w.max_1rm,
    w.total_volume,
    w.set_count,
    w.prev_max_weight,
    w.prev_volume,
    e.name AS exercise_name,
    e.muscle_group,
    CASE
        WHEN w.prev_max_weight IS NOT NULL AND w.prev_max_weight > 0 THEN
            ROUND(((w.max_weight - w.prev_max_weight) / w.prev_max_weight) * 100, 1)
        ELSE NULL
    END AS weight_change_pct,
    CASE
        WHEN w.prev_volume IS NOT NULL AND w.prev_volume > 0 THEN
            ROUND(((w.total_volume - w.prev_volume) / w.prev_volume) * 100, 1)
        ELSE NULL
    END AS volume_change_pct
FROM with_comparison w
INNER JOIN exercise_dim e ON w.exercise_id = e.exercise_id
ORDER BY week_start DESC, exercise_name
`;
